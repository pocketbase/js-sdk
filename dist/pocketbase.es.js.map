{"version":3,"file":"pocketbase.es.js","sources":["../node_modules/tslib/tslib.es6.js","../src/ClientResponseError.ts","../src/stores/utils/jwt.ts","../src/stores/utils/cookie.ts","../src/models/utils/BaseModel.ts","../src/models/Record.ts","../src/models/Admin.ts","../src/stores/BaseAuthStore.ts","../src/stores/LocalAuthStore.ts","../src/services/utils/BaseService.ts","../src/services/SettingsService.ts","../src/models/utils/ListResult.ts","../src/services/utils/CrudService.ts","../src/services/utils/BaseCrudService.ts","../src/services/AdminService.ts","../src/models/ExternalAuth.ts","../src/services/RecordService.ts","../src/models/utils/SchemaField.ts","../src/models/Collection.ts","../src/services/CollectionService.ts","../src/models/LogRequest.ts","../src/services/LogService.ts","../src/services/RealtimeService.ts","../src/services/HealthService.ts","../src/services/FileService.ts","../src/services/BackupService.ts","../src/Client.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.push(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.push(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n","/**\n * ClientResponseError is a custom Error class that is intended to wrap\n * and normalize any error thrown by `Client.send()`.\n */\nexport default class ClientResponseError extends Error {\n    url: string                    = '';\n    status: number                 = 0;\n    response: {[key: string]: any} = {};\n    isAbort:  boolean              = false;\n    originalError: any             = null;\n\n    constructor(errData?: any) {\n        super(\"ClientResponseError\");\n\n        // Set the prototype explicitly.\n        // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, ClientResponseError.prototype);\n\n        if (errData !== null && typeof errData === 'object') {\n            this.url           = typeof errData.url === 'string' ? errData.url : '';\n            this.status        = typeof errData.status === 'number' ? errData.status : 0;\n            this.isAbort       = !!errData.isAbort;\n            this.originalError = errData.originalError;\n\n            if (errData.response !== null && typeof errData.response === 'object')  {\n                this.response =  errData.response;\n            } else if (errData.data !== null && typeof errData.data === 'object')  {\n                this.response =  errData.data;\n            } else {\n                this.response =  {};\n            }\n        }\n\n        if (!this.originalError && !(errData instanceof ClientResponseError)) {\n            this.originalError = errData;\n        }\n\n        if (typeof DOMException !== 'undefined' && errData instanceof DOMException) {\n            this.isAbort = true;\n        }\n\n        this.name = \"ClientResponseError \" + this.status;\n        this.message = this.response?.message;\n        if (!this.message) {\n            if (this.isAbort) {\n                this.message = 'The request was autocancelled. You can find more info in https://github.com/pocketbase/js-sdk#auto-cancellation.';\n            } else if (this.originalError?.cause?.message?.includes(\"ECONNREFUSED ::1\")) {\n                this.message = 'Failed to connect to the PocketBase server. Try changing the SDK URL from localhost to 127.0.0.1 (https://github.com/pocketbase/js-sdk/issues/21).';\n            } else {\n                this.message = 'Something went wrong while processing your request.';\n            }\n        }\n    }\n\n    /**\n     * Alias for `this.response` to preserve the backward compatibility.\n     */\n    get data() {\n        return this.response;\n    }\n\n    /**\n     * Make a POJO's copy of the current error class instance.\n     * @see https://github.com/vuex-orm/vuex-orm/issues/255\n     */\n    toJSON() {\n        return { ...this };\n    }\n}\n","let atobPolyfill: Function;\nif (typeof atob === 'function') {\n    atobPolyfill = atob\n} else {\n    /**\n     * The code was extracted from:\n     * https://github.com/davidchambers/Base64.js\n     */\n    atobPolyfill = (input: any) => {\n        const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n        let str = String(input).replace(/=+$/, \"\");\n        if (str.length % 4 == 1) {\n            throw new Error(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n        }\n\n        for (\n            // initialize result and counters\n            var bc = 0, bs, buffer, idx = 0, output = \"\";\n            // get next character\n            (buffer = str.charAt(idx++));\n            // character found in table? initialize bit storage and add its ascii value;\n            ~buffer &&\n            ((bs = bc % 4 ? (bs as any) * 64 + buffer : buffer),\n                // and if not first of each 4 characters,\n                // convert the first 8 bits to one ascii character\n                bc++ % 4) ?\n            (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6)))) :\n            0\n        ) {\n            // try to find character in table (0-63, not found => -1)\n            buffer = chars.indexOf(buffer);\n        }\n\n        return output;\n    };\n}\n\n/**\n * Returns JWT token's payload data.\n */\nexport function getTokenPayload(token: string): { [key: string]: any } {\n    if (token) {\n        try {\n            const encodedPayload = decodeURIComponent(atobPolyfill(token.split('.')[1]).split('').map(function (c: string) {\n                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n            }).join(''));\n\n            return JSON.parse(encodedPayload) || {};\n        } catch (e) {\n        }\n    }\n\n    return {};\n}\n\n/**\n * Checks whether a JWT token is expired or not.\n * Tokens without `exp` payload key are considered valid.\n * Tokens with empty payload (eg. invalid token strings) are considered expired.\n *\n * @param token The token to check.\n * @param [expirationThreshold] Time in seconds that will be subtracted from the token `exp` property.\n */\nexport function isTokenExpired(token: string, expirationThreshold = 0): boolean {\n    let payload = getTokenPayload(token);\n\n    if (\n        Object.keys(payload).length > 0 &&\n        (!payload.exp || (payload.exp - expirationThreshold) > (Date.now() / 1000))\n    ) {\n        return false;\n    }\n\n    return true;\n}\n","/**\n * -------------------------------------------------------------------\n * Simple cookie parse and serialize utilities mostly based on the\n * node module https://github.com/jshttp/cookie.\n * -------------------------------------------------------------------\n */\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\nexport interface ParseOptions{\n    decode?: (val: string) => string,\n}\n\n/**\n* Parses the given cookie header string into an object\n* The object has the various cookies as keys(names) => values\n*/\nexport function cookieParse(str: string, options?: ParseOptions): { [key: string]: any }  {\n    const result: { [key: string]: any } = {};\n\n    if (typeof str !== 'string') {\n        return result;\n    }\n\n    const opt    = Object.assign({}, options || {});\n    const decode = opt.decode || defaultDecode;\n\n    let index = 0;\n    while (index < str.length) {\n        const eqIdx = str.indexOf('=', index);\n\n        // no more cookie pairs\n        if (eqIdx === -1) {\n            break;\n        }\n\n        let endIdx = str.indexOf(';', index);\n\n        if (endIdx === -1) {\n            endIdx = str.length;\n        } else if (endIdx < eqIdx) {\n            // backtrack on prior semicolon\n            index = str.lastIndexOf(';', eqIdx - 1) + 1;\n            continue;\n        }\n\n        const key = str.slice(index, eqIdx).trim();\n\n        // only assign once\n        if (undefined === result[key]) {\n            let val = str.slice(eqIdx + 1, endIdx).trim();\n\n            // quoted values\n            if (val.charCodeAt(0) === 0x22) {\n                val = val.slice(1, -1);\n            }\n\n            try {\n                result[key] = decode(val);\n            } catch (_) {\n                result[key] = val; // no decoding\n            }\n        }\n\n        index = endIdx + 1;\n    }\n\n    return result;\n};\n\nexport interface SerializeOptions{\n    encode?:   (val: string | number | boolean) => string,\n    maxAge?:   number,\n    domain?:   string,\n    path?:     string,\n    expires?:  Date,\n    httpOnly?: boolean,\n    secure?:   boolean,\n    priority?: string,\n    sameSite?: boolean|string,\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * ```js\n * cookieSerialize('foo', 'bar', { httpOnly: true }) // \"foo=bar; httpOnly\"\n * ```\n */\nexport function cookieSerialize(name: string, val: string, options?: SerializeOptions): string {\n    const opt    = Object.assign({}, options || {});\n    const encode = opt.encode || defaultEncode;\n\n    if (!fieldContentRegExp.test(name)) {\n        throw new TypeError('argument name is invalid');\n    }\n\n    const value = encode(val);\n\n    if (value && !fieldContentRegExp.test(value)) {\n        throw new TypeError('argument val is invalid');\n    }\n\n    let result = name + '=' + value;\n\n    if (opt.maxAge != null) {\n        const maxAge = opt.maxAge - 0;\n\n        if (isNaN(maxAge) || !isFinite(maxAge)) {\n            throw new TypeError('option maxAge is invalid');\n        }\n\n        result += '; Max-Age=' + Math.floor(maxAge);\n    }\n\n    if (opt.domain) {\n        if (!fieldContentRegExp.test(opt.domain)) {\n            throw new TypeError('option domain is invalid');\n        }\n\n        result += '; Domain=' + opt.domain;\n    }\n\n    if (opt.path) {\n        if (!fieldContentRegExp.test(opt.path)) {\n            throw new TypeError('option path is invalid');\n        }\n\n        result += '; Path=' + opt.path;\n    }\n\n    if (opt.expires) {\n        if (!isDate(opt.expires) || isNaN(opt.expires.valueOf())) {\n            throw new TypeError('option expires is invalid');\n        }\n\n        result += '; Expires=' + opt.expires.toUTCString();\n    }\n\n    if (opt.httpOnly) {\n        result += '; HttpOnly';\n    }\n\n    if (opt.secure) {\n        result += '; Secure';\n    }\n\n    if (opt.priority) {\n        const priority = typeof opt.priority === 'string' ? opt.priority.toLowerCase() : opt.priority;\n\n        switch (priority) {\n            case 'low':\n                result += '; Priority=Low';\n                break;\n            case 'medium':\n                result += '; Priority=Medium';\n                break;\n            case 'high':\n                result += '; Priority=High';\n                break;\n            default:\n                throw new TypeError('option priority is invalid');\n        }\n    }\n\n    if (opt.sameSite) {\n        const sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n        switch (sameSite) {\n            case true:\n                result += '; SameSite=Strict';\n                break;\n            case 'lax':\n                result += '; SameSite=Lax';\n                break;\n            case 'strict':\n                result += '; SameSite=Strict';\n                break;\n            case 'none':\n                result += '; SameSite=None';\n                break;\n            default:\n                throw new TypeError('option sameSite is invalid');\n        }\n    }\n\n    return result;\n};\n\n/**\n * Default URL-decode string value function.\n * Optimized to skip native call when no `%`.\n */\nfunction defaultDecode(val: string): string {\n    return val.indexOf('%') !== -1\n        ? decodeURIComponent(val)\n        : val;\n}\n\n/**\n * Default URL-encode value function.\n */\nfunction defaultEncode(val: string | number | boolean): string {\n    return encodeURIComponent(val);\n}\n\n/**\n * Determines if value is a Date.\n */\nfunction isDate(val: any): boolean {\n    return (\n        Object.prototype.toString.call(val) === '[object Date]' ||\n        val instanceof Date\n    );\n}\n","export default abstract class BaseModel {\n    [key: string]: any,\n\n    id!:      string;\n    created!: string;\n    updated!: string;\n\n    constructor(data: { [key: string]: any } = {}) {\n        this.$load(data || {});\n    }\n\n    /**\n     * Alias of this.$load(data).\n     */\n    load(data: { [key: string]: any }) {\n        return this.$load(data);\n    }\n\n    /**\n     * Loads `data` into the current model.\n     */\n    $load(data: { [key: string]: any }) {\n        for (const [key, value] of Object.entries(data)) {\n            this[key] = value;\n        }\n\n        // normalize known fields\n        this.id      = typeof data.id      !== 'undefined' ? data.id      : '';\n        this.created = typeof data.created !== 'undefined' ? data.created : '';\n        this.updated = typeof data.updated !== 'undefined' ? data.updated : '';\n    }\n\n    /**\n     * Returns whether the current loaded data represent a stored db record.\n     */\n    get $isNew(): boolean {\n        return !this.id;\n    }\n\n    /**\n     * Alias of this.clone().\n     */\n    clone(): BaseModel {\n        return this.$clone();\n    }\n\n    /**\n     * Creates a deep clone of the current model.\n     */\n    $clone(): BaseModel {\n        const clone = typeof structuredClone === 'function' ?\n            structuredClone(this) : JSON.parse(JSON.stringify(this));\n\n        return new (this.constructor as any)(clone);\n    }\n\n    /**\n     * Alias of this.$export().\n     */\n    export(): { [key: string]: any } {\n        return this.$export();\n    }\n\n    /**\n     * Exports all model properties as a new plain object.\n     */\n    $export(): { [key: string]: any } {\n        return typeof structuredClone === 'function' ?\n            structuredClone(this) : Object.assign({}, this);\n    }\n}\n","import BaseModel from '@/models/utils/BaseModel';\n\nexport default class Record extends BaseModel {\n    collectionId!:   string;\n    collectionName!: string;\n    expand!:         {[key: string]: Record|Array<Record>};\n\n    /**\n     * @inheritdoc\n     */\n    $load(data: { [key: string]: any }) {\n        super.$load(data);\n\n        // normalize common fields\n        this.collectionId   = typeof data.collectionId   === 'string' ? data.collectionId   : '';\n        this.collectionName = typeof data.collectionName === 'string' ? data.collectionName : '';\n\n        // normalize expand items\n        this._loadExpand(data.expand);\n    }\n\n    /**\n     * Loads the provided expand items and recursively normalizes each\n     * item to a `Record|Array<Record>`.\n     */\n    private _loadExpand(expand: { [key: string]: any }) {\n        expand = expand || {};\n        this.expand = {};\n\n        for (const key in expand) {\n            if (Array.isArray(expand[key])) {\n                this.expand[key] = expand[key].map((data: any) => new Record(data || {}));\n            } else {\n                this.expand[key] = new Record(expand[key] || {});\n            }\n        }\n    }\n}\n","import BaseModel from '@/models/utils/BaseModel';\n\nexport default class Admin extends BaseModel {\n    avatar!: number;\n    email!:  string;\n\n    /**\n     * @inheritdoc\n     */\n    $load(data: { [key: string]: any }) {\n        super.$load(data);\n\n        this.avatar = typeof data.avatar === 'number' ? data.avatar : 0;\n        this.email  = typeof data.email  === 'string' ? data.email  : '';\n    }\n}\n","import { cookieParse, cookieSerialize, SerializeOptions } from '@/stores/utils/cookie';\nimport { isTokenExpired, getTokenPayload } from '@/stores/utils/jwt';\nimport Record  from '@/models/Record';\nimport Admin from '@/models/Admin';\n\nexport type OnStoreChangeFunc = (token: string, model: Record|Admin|null) => void;\n\nconst defaultCookieKey = 'pb_auth';\n\n/**\n * Base AuthStore class that is intended to be extended by all other\n * PocketBase AuthStore implementations.\n */\nexport default abstract class BaseAuthStore {\n    protected baseToken: string = '';\n    protected baseModel: Record|Admin|null = null;\n\n    private _onChangeCallbacks: Array<OnStoreChangeFunc> = [];\n\n    /**\n     * Retrieves the stored token (if any).\n     */\n    get token(): string {\n        return this.baseToken;\n    }\n\n    /**\n     * Retrieves the stored model data (if any).\n     */\n    get model(): Record|Admin|null {\n        return this.baseModel;\n    }\n\n    /**\n     * Loosely checks if the store has valid token (aka. existing and unexpired exp claim).\n     */\n    get isValid(): boolean {\n        return !isTokenExpired(this.token);\n    }\n\n    /**\n     * Saves the provided new token and model data in the auth store.\n     */\n    save(token: string, model: Record|Admin|null): void {\n        this.baseToken = token || '';\n\n        // normalize the model instance\n        if (model !== null && typeof model === 'object') {\n            this.baseModel = typeof (model as any).collectionId !== 'undefined' ?\n                new Record(model) : new Admin(model);\n        } else {\n            this.baseModel = null;\n        }\n\n        this.triggerChange();\n    }\n\n    /**\n     * Removes the stored token and model data form the auth store.\n     */\n    clear(): void {\n        this.baseToken = '';\n        this.baseModel = null;\n        this.triggerChange();\n    }\n\n    /**\n     * Parses the provided cookie string and updates the store state\n     * with the cookie's token and model data.\n     *\n     * NB! This function doesn't validate the token or its data.\n     * Usually this isn't a concern if you are interacting only with the\n     * PocketBase API because it has the proper server-side security checks in place,\n     * but if you are using the store `isValid` state for permission controls\n     * in a node server (eg. SSR), then it is recommended to call `authRefresh()`\n     * after loading the cookie to ensure an up-to-date token and model state.\n     * For example:\n     *\n     * ```js\n     * pb.authStore.loadFromCookie(\"cookie string...\");\n     *\n     * try {\n     *     // get an up-to-date auth store state by veryfing and refreshing the loaded auth model (if any)\n     *     pb.authStore.isValid && await pb.collection('users').authRefresh();\n     * } catch (_) {\n     *     // clear the auth store on failed refresh\n     *     pb.authStore.clear();\n     * }\n     * ```\n     */\n    loadFromCookie(cookie: string, key = defaultCookieKey): void {\n        const rawData = cookieParse(cookie || '')[key] || '';\n\n        let data: { [key: string]: any } = {};\n        try {\n            data = JSON.parse(rawData);\n            // normalize\n            if (typeof data === null || typeof data !== 'object' || Array.isArray(data)) {\n                data = {};\n            }\n        } catch (_) {}\n\n        this.save(data.token || '', data.model || null);\n    }\n\n    /**\n     * Exports the current store state as cookie string.\n     *\n     * By default the following optional attributes are added:\n     * - Secure\n     * - HttpOnly\n     * - SameSite=Strict\n     * - Path=/\n     * - Expires={the token expiration date}\n     *\n     * NB! If the generated cookie exceeds 4096 bytes, this method will\n     * strip the model data to the bare minimum to try to fit within the\n     * recommended size in https://www.rfc-editor.org/rfc/rfc6265#section-6.1.\n     */\n    exportToCookie(options?: SerializeOptions, key = defaultCookieKey): string {\n        const defaultOptions: SerializeOptions = {\n            secure:   true,\n            sameSite: true,\n            httpOnly: true,\n            path:     \"/\",\n        };\n\n        // extract the token expiration date\n        const payload = getTokenPayload(this.token);\n        if (payload?.exp) {\n            defaultOptions.expires = new Date(payload.exp * 1000);\n        } else {\n            defaultOptions.expires = new Date('1970-01-01');\n        }\n\n        // merge with the user defined options\n        options = Object.assign({}, defaultOptions, options);\n\n        const rawData = {\n            token: this.token,\n            model: this.model?.export() || null,\n        };\n\n        let result = cookieSerialize(key, JSON.stringify(rawData), options);\n\n        const resultLength = typeof Blob !== 'undefined' ?\n            (new Blob([result])).size : result.length;\n\n        // strip down the model data to the bare minimum\n        if (rawData.model && resultLength > 4096) {\n            rawData.model = {id: rawData?.model?.id, email: rawData?.model?.email};\n            if (this.model instanceof Record) {\n                rawData.model.username     = this.model.username;\n                rawData.model.verified     = this.model.verified;\n                rawData.model.collectionId = this.model.collectionId;\n            }\n            result = cookieSerialize(key, JSON.stringify(rawData), options);\n        }\n\n        return result;\n    }\n\n    /**\n     * Register a callback function that will be called on store change.\n     *\n     * You can set the `fireImmediately` argument to true in order to invoke\n     * the provided callback right after registration.\n     *\n     * Returns a removal function that you could call to \"unsubscribe\" from the changes.\n     */\n    onChange(callback: OnStoreChangeFunc, fireImmediately = false): () => void {\n        this._onChangeCallbacks.push(callback);\n\n        if (fireImmediately) {\n            callback(this.token, this.model);\n        }\n\n        return () => {\n            for (let i = this._onChangeCallbacks.length - 1; i >= 0; i--) {\n                if (this._onChangeCallbacks[i] == callback) {\n                    delete this._onChangeCallbacks[i];    // removes the function reference\n                    this._onChangeCallbacks.splice(i, 1); // reindex the array\n                    return;\n                }\n            }\n        }\n    }\n\n    protected triggerChange(): void {\n        for (const callback of this._onChangeCallbacks) {\n            callback && callback(this.token, this.model);\n        }\n    }\n}\n","import BaseAuthStore from '@/stores/BaseAuthStore';\nimport Record        from '@/models/Record';\nimport Admin         from '@/models/Admin';\n\n/**\n * The default token store for browsers with auto fallback\n * to runtime/memory if local storage is undefined (eg. in node env).\n */\nexport default class LocalAuthStore extends BaseAuthStore {\n    private storageFallback: { [key: string]: any } = {};\n    private storageKey: string\n\n    constructor(storageKey = \"pocketbase_auth\") {\n        super();\n\n        this.storageKey = storageKey;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get token(): string {\n        const data = this._storageGet(this.storageKey) || {};\n\n        return data.token || '';\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get model(): Record|Admin|null {\n        const data = this._storageGet(this.storageKey) || {};\n\n        if (\n            data === null ||\n            typeof data !== 'object' ||\n            data.model === null ||\n            typeof data.model !== 'object'\n        ) {\n            return null;\n        }\n\n        // admins don't have `collectionId` prop\n        if (typeof data.model?.collectionId === 'undefined') {\n            return new Admin(data.model);\n        }\n\n        return new Record(data.model);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    save(token: string, model: Record|Admin|null) {\n        this._storageSet(this.storageKey, {\n            'token': token,\n            'model': model,\n        });\n\n        super.save(token, model);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    clear() {\n        this._storageRemove(this.storageKey);\n\n        super.clear();\n    }\n\n    // ---------------------------------------------------------------\n    // Internal helpers:\n    // ---------------------------------------------------------------\n\n    /**\n     * Retrieves `key` from the browser's local storage\n     * (or runtime/memory if local storage is undefined).\n     */\n    private _storageGet(key: string): any {\n        if (typeof window !== 'undefined' && window?.localStorage) {\n            const rawValue = window.localStorage.getItem(key) || '';\n            try {\n                return JSON.parse(rawValue);\n            } catch (e) { // not a json\n                return rawValue;\n            }\n        }\n\n        // fallback\n        return this.storageFallback[key];\n    }\n\n    /**\n     * Stores a new data in the browser's local storage\n     * (or runtime/memory if local storage is undefined).\n     */\n    private _storageSet(key: string, value: any) {\n        if (typeof window !== 'undefined' && window?.localStorage) {\n            // store in local storage\n            let normalizedVal = value;\n            if (typeof value !== 'string') {\n                normalizedVal = JSON.stringify(value);\n            }\n            window.localStorage.setItem(key, normalizedVal);\n        } else {\n            // store in fallback\n            this.storageFallback[key] = value;\n        }\n    }\n\n    /**\n     * Removes `key` from the browser's local storage and the runtime/memory.\n     */\n    private _storageRemove(key: string) {\n        // delete from local storage\n        if (typeof window !== 'undefined' && window?.localStorage) {\n            window.localStorage?.removeItem(key);\n        }\n\n        // delete from fallback\n        delete this.storageFallback[key];\n    }\n}\n","import Client from '@/Client';\n\n/**\n * BaseService class that should be inherited from all API services.\n */\nexport default abstract class BaseService {\n    readonly client: Client\n\n    constructor(client: Client) {\n        this.client = client;\n    }\n}\n","import BaseService         from '@/services/utils/BaseService';\nimport { BaseQueryParams } from '@/services/utils/QueryParams';\n\ninterface appleClientSecret {\n    secret: string;\n}\n\nexport default class SettingsService extends BaseService {\n    /**\n     * Fetch all available app settings.\n     */\n    getAll(queryParams: BaseQueryParams = {}): Promise<{ [key: string]: any }> {\n        return this.client.send('/api/settings', {\n            'method': 'GET',\n            'params': queryParams,\n        }).then((responseData) => responseData || {});\n    }\n\n    /**\n     * Bulk updates app settings.\n     */\n    update(bodyParams = {}, queryParams: BaseQueryParams = {}): Promise<{ [key: string]: any }> {\n        return this.client.send('/api/settings', {\n            'method': 'PATCH',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then((responseData) => responseData || {});\n    }\n\n    /**\n     * Performs a S3 filesystem connection test.\n     *\n     * The currently supported `filesystem` are \"storage\" and \"backups\".\n     */\n    testS3(filesystem: string = \"storage\", queryParams: BaseQueryParams = {}): Promise<boolean> {\n        const bodyParams = {\n            'filesystem': filesystem,\n        };\n\n        return this.client.send('/api/settings/test/s3', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Sends a test email.\n     *\n     * The possible `emailTemplate` values are:\n     * - verification\n     * - password-reset\n     * - email-change\n     */\n    testEmail(toEmail: string, emailTemplate: string, queryParams: BaseQueryParams = {}): Promise<boolean> {\n        const bodyParams = {\n            'email':    toEmail,\n            'template': emailTemplate,\n        };\n\n        return this.client.send('/api/settings/test/email', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Generates a new Apple OAuth2 client secret.\n     */\n    generateAppleClientSecret(\n        clientId: string,\n        teamId: string,\n        keyId: string,\n        privateKey: string,\n        duration: number,\n        bodyParams = {},\n        queryParams: BaseQueryParams = {}\n    ): Promise<appleClientSecret> {\n        bodyParams = Object.assign({\n            clientId,\n            teamId,\n            keyId,\n            privateKey,\n            duration,\n        }, bodyParams);\n\n        return this.client.send('/api/settings/apple/generate-client-secret', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        });\n    }\n}\n","import BaseModel from './BaseModel';\n\nexport default class ListResult<M = BaseModel> {\n    page!:       number;\n    perPage!:    number;\n    totalItems!: number;\n    totalPages!: number;\n    items!:      Array<M>;\n\n    constructor(\n        page: number,\n        perPage: number,\n        totalItems: number,\n        totalPages: number,\n        items: Array<M>,\n    ) {\n        this.page       = page > 0 ? page : 1;\n        this.perPage    = perPage >= 0 ? perPage : 0;\n        this.totalItems = totalItems >= 0 ? totalItems : 0;\n        this.totalPages = totalPages >= 0 ? totalPages : 0;\n        this.items      = items || [];\n    }\n}\n","import ListResult      from '@/models/utils/ListResult';\nimport BaseModel       from '@/models/utils/BaseModel';\nimport BaseCrudService from '@/services/utils/BaseCrudService';\nimport {\n    BaseQueryParams,\n    ListQueryParams,\n    FullListQueryParams\n} from '@/services/utils/QueryParams';\n\nexport default abstract class CrudService<M extends BaseModel> extends BaseCrudService<M> {\n    /**\n     * Base path for the crud actions (without trailing slash, eg. '/admins').\n     */\n    abstract get baseCrudPath(): string\n\n    /**\n     * Returns a promise with all list items batch fetched at once\n     * (by default 200 items per request; to change it set the `batch` query param).\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    getFullList<T = M>(queryParams?: FullListQueryParams): Promise<Array<T>>\n\n    /**\n     * Legacy version of getFullList with explicitly specified batch size.\n     */\n    getFullList<T = M>(batch?: number, queryParams?: ListQueryParams): Promise<Array<T>>\n\n    getFullList<T = M>(batchOrqueryParams?: number|FullListQueryParams, queryParams?: ListQueryParams): Promise<Array<T>> {\n        if (typeof batchOrqueryParams == \"number\") {\n            return this._getFullList<T>(this.baseCrudPath, batchOrqueryParams, queryParams);\n        }\n\n        const params = Object.assign({}, batchOrqueryParams, queryParams);\n\n        return this._getFullList<T>(this.baseCrudPath, params.batch || 200, params);\n    }\n\n    /**\n     * Returns paginated items list.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    getList<T = M>(page = 1, perPage = 30, queryParams: ListQueryParams = {}): Promise<ListResult<T>> {\n        return this._getList<T>(this.baseCrudPath, page, perPage, queryParams);\n    }\n\n    /**\n     * Returns the first found item by the specified filter.\n     *\n     * Internally it calls `getList(1, 1, { filter })` and returns the\n     * first found item.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * For consistency with `getOne`, this method will throw a 404\n     * ClientResponseError if no item was found.\n     */\n    getFirstListItem<T = M>(filter: string, queryParams: BaseQueryParams = {}): Promise<T> {\n        return this._getFirstListItem<T>(this.baseCrudPath, filter, queryParams);\n    }\n\n    /**\n     * Returns single item by its id.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    getOne<T = M>(id: string, queryParams: BaseQueryParams = {}): Promise<T> {\n        return this._getOne<T>(this.baseCrudPath, id, queryParams);\n    }\n\n    /**\n     * Creates a new item.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    create<T = M>(bodyParams = {}, queryParams: BaseQueryParams = {}): Promise<T> {\n        return this._create<T>(this.baseCrudPath, bodyParams, queryParams);\n    }\n\n    /**\n     * Updates an existing item by its id.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    update<T = M>(id: string, bodyParams = {}, queryParams: BaseQueryParams = {}): Promise<T> {\n        return this._update<T>(this.baseCrudPath, id, bodyParams, queryParams);\n    }\n\n    /**\n     * Deletes an existing item by its id.\n     */\n    delete(id: string, queryParams: BaseQueryParams = {}): Promise<boolean> {\n        return this._delete(this.baseCrudPath, id, queryParams);\n    }\n}\n","import BaseModel           from '@/models/utils/BaseModel';\nimport ListResult          from '@/models/utils/ListResult';\nimport BaseService         from '@/services/utils/BaseService';\nimport ClientResponseError from '@/ClientResponseError';\nimport {\n    BaseQueryParams,\n    ListQueryParams\n} from '@/services/utils/QueryParams';\n\n// @todo since there is no longer need of SubCrudService consider merging with CrudService in v0.9+\nexport default abstract class BaseCrudService<M extends BaseModel> extends BaseService {\n    /**\n     * Response data decoder.\n     */\n    abstract decode(data: { [key: string]: any }): M\n\n    /**\n     * Returns a promise with all list items batch fetched at once.\n     */\n    protected _getFullList<T = M>(basePath: string, batchSize = 200, queryParams: ListQueryParams = {}): Promise<Array<T>> {\n        var result: Array<T> = [];\n\n        let request = async (page: number): Promise<Array<any>> => {\n            return this._getList(basePath, page, batchSize || 200, queryParams).then((list) => {\n                const castedList = (list as any as ListResult<T>);\n                const items = castedList.items;\n                const totalItems = castedList.totalItems;\n\n                result = result.concat(items);\n\n                if (items.length && totalItems > result.length) {\n                    return request(page + 1);\n                }\n\n                return result;\n            });\n        }\n\n        return request(1);\n    }\n\n    /**\n     * Returns paginated items list.\n     */\n    protected _getList<T = M>(basePath: string, page = 1, perPage = 30, queryParams: ListQueryParams = {}): Promise<ListResult<T>> {\n        queryParams = Object.assign({\n            'page': page,\n            'perPage': perPage,\n        }, queryParams);\n\n        return this.client.send(basePath, {\n            'method': 'GET',\n            'params': queryParams,\n        }).then((responseData: any) => {\n            const items: Array<T> = [];\n            if (responseData?.items) {\n                responseData.items = responseData.items || [];\n                for (const item of responseData.items) {\n                    items.push(this.decode(item) as any as T);\n                }\n            }\n\n            return new ListResult<T>(\n                responseData?.page || 1,\n                responseData?.perPage || 0,\n                responseData?.totalItems || 0,\n                responseData?.totalPages || 0,\n                items,\n            );\n        });\n    }\n\n    /**\n     * Returns single item by its id.\n     */\n    protected _getOne<T = M>(basePath: string, id: string, queryParams: BaseQueryParams = {}): Promise<T> {\n        return this.client.send(basePath + '/' + encodeURIComponent(id), {\n            'method': 'GET',\n            'params': queryParams\n        }).then((responseData: any) => this.decode(responseData) as any as T);\n    }\n\n    /**\n     * Returns the first found item by a list filter.\n     *\n     * Internally it calls `_getList(basePath, 1, 1, { filter })` and returns its\n     * first item.\n     *\n     * For consistency with `_getOne`, this method will throw a 404\n     * ClientResponseError if no item was found.\n     */\n    protected _getFirstListItem<T = M>(basePath: string, filter: string, queryParams: BaseQueryParams = {}): Promise<T> {\n        queryParams = Object.assign({\n            'filter': filter,\n            '$cancelKey': 'one_by_filter_' + basePath + \"_\" + filter,\n        }, queryParams);\n\n        return this._getList<T>(basePath, 1, 1, queryParams)\n            .then((result) => {\n                if (!result?.items?.length) {\n                    throw new ClientResponseError({\n                        status: 404,\n                        data: {\n                            code: 404,\n                            message: \"The requested resource wasn't found.\",\n                            data: {},\n                        },\n                    });\n                }\n\n                return result.items[0];\n            });\n    }\n\n    /**\n     * Creates a new item.\n     */\n    protected _create<T = M>(basePath: string, bodyParams = {}, queryParams: BaseQueryParams = {}): Promise<T> {\n        return this.client.send(basePath, {\n            'method': 'POST',\n            'params': queryParams,\n            'body': bodyParams,\n        }).then((responseData: any) => this.decode(responseData) as any as T);\n    }\n\n    /**\n     * Updates an existing item by its id.\n     */\n    protected _update<T = M>(basePath: string, id: string, bodyParams = {}, queryParams: BaseQueryParams = {}): Promise<T> {\n        return this.client.send(basePath + '/' + encodeURIComponent(id), {\n            'method': 'PATCH',\n            'params': queryParams,\n            'body': bodyParams,\n        }).then((responseData: any) => this.decode(responseData) as any as T);\n    }\n\n    /**\n     * Deletes an existing item by its id.\n     */\n    protected _delete(basePath: string, id: string, queryParams: BaseQueryParams = {}): Promise<boolean> {\n        return this.client.send(basePath + '/' + encodeURIComponent(id), {\n            'method': 'DELETE',\n            'params': queryParams,\n        }).then(() => true);\n    }\n}\n","import Admin               from '@/models/Admin';\nimport CrudService         from '@/services/utils/CrudService';\nimport { BaseQueryParams } from '@/services/utils/QueryParams';\n\nexport interface AdminAuthResponse {\n    [key: string]: any;\n\n    token: string;\n    admin: Admin;\n}\n\nexport default class AdminService extends CrudService<Admin> {\n    /**\n     * @inheritdoc\n     */\n    decode(data: { [key: string]: any }): Admin {\n        return new Admin(data);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return '/api/admins';\n    }\n\n    // ---------------------------------------------------------------\n    // Post update/delete AuthStore sync\n    // ---------------------------------------------------------------\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the updated id, then\n     * on success the `client.authStore.model` will be updated with the result.\n     */\n    update<T = Admin>(id: string, bodyParams = {}, queryParams: BaseQueryParams = {}): Promise<T> {\n        return super.update<Admin>(id, bodyParams, queryParams).then((item) => {\n            // update the store state if the updated item id matches with the stored model\n            if (\n                this.client.authStore.model &&\n                typeof this.client.authStore.model?.collectionId === 'undefined' && // is not record auth\n                this.client.authStore.model?.id === item?.id\n            ) {\n                this.client.authStore.save(this.client.authStore.token, item);\n            }\n\n            return item as any as T;\n        });\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the deleted id,\n     * then on success the `client.authStore` will be cleared.\n     */\n    delete(id: string, queryParams: BaseQueryParams = {}): Promise<boolean> {\n        return super.delete(id, queryParams).then((success) => {\n            // clear the store state if the deleted item id matches with the stored model\n            if (\n                success &&\n                this.client.authStore.model &&\n                typeof this.client.authStore.model?.collectionId === 'undefined' && // is not record auth\n                this.client.authStore.model?.id === id\n            ) {\n                this.client.authStore.clear();\n            }\n            return success;\n        });\n    }\n\n    // ---------------------------------------------------------------\n    // Auth handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * Prepare successful authorize response.\n     */\n    protected authResponse(responseData: any): AdminAuthResponse {\n        const admin = this.decode(responseData?.admin || {});\n\n        if (responseData?.token && responseData?.admin) {\n            this.client.authStore.save(responseData.token, admin);\n        }\n\n        return Object.assign({}, responseData, {\n            // normalize common fields\n            'token': responseData?.token || '',\n            'admin': admin,\n        });\n    }\n\n    /**\n     * Authenticate an admin account with its email and password\n     * and returns a new admin token and data.\n     *\n     * On success this method automatically updates the client's AuthStore data.\n     */\n    authWithPassword(\n        email: string,\n        password: string,\n        bodyParams = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<AdminAuthResponse> {\n        bodyParams = Object.assign({\n            'identity': email,\n            'password': password,\n        }, bodyParams);\n\n        return this.client.send(this.baseCrudPath + '/auth-with-password', {\n            'method':  'POST',\n            'params':  queryParams,\n            'body':    bodyParams,\n        }).then(this.authResponse.bind(this));\n    }\n\n    /**\n     * Refreshes the current admin authenticated instance and\n     * returns a new token and admin data.\n     *\n     * On success this method automatically updates the client's AuthStore data.\n     */\n    authRefresh(bodyParams = {}, queryParams: BaseQueryParams = {}): Promise<AdminAuthResponse> {\n        return this.client.send(this.baseCrudPath + '/auth-refresh', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(this.authResponse.bind(this));\n    }\n\n    /**\n     * Sends admin password reset request.\n     */\n    requestPasswordReset(\n        email: string,\n        bodyParams = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'email': email,\n        }, bodyParams);\n\n        return this.client.send(this.baseCrudPath + '/request-password-reset', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Confirms admin password reset request.\n     */\n    confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        bodyParams = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'token':           passwordResetToken,\n            'password':        password,\n            'passwordConfirm': passwordConfirm,\n        }, bodyParams);\n\n        return this.client.send(this.baseCrudPath + '/confirm-password-reset', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n}\n","import BaseModel from '@/models/utils/BaseModel';\n\nexport default class ExternalAuth extends BaseModel {\n    recordId!:     string;\n    collectionId!: string;\n    provider!:     string;\n    providerId!:   string;\n\n    /**\n     * @inheritdoc\n     */\n    $load(data: { [key: string]: any }) {\n        super.$load(data);\n\n        this.recordId     = typeof data.recordId     === 'string' ? data.recordId     : '';\n        this.collectionId = typeof data.collectionId === 'string' ? data.collectionId : '';\n        this.provider     = typeof data.provider     === 'string' ? data.provider     : '';\n        this.providerId   = typeof data.providerId   === 'string' ? data.providerId   : '';\n    }\n}\n","import Client              from '@/Client';\nimport ClientResponseError from '@/ClientResponseError';\nimport Record              from '@/models/Record';\nimport ExternalAuth        from '@/models/ExternalAuth';\nimport ListResult          from '@/models/utils/ListResult';\nimport CrudService         from '@/services/utils/CrudService';\nimport { UnsubscribeFunc } from '@/services/RealtimeService';\nimport {\n    BaseQueryParams,\n    RecordQueryParams,\n    RecordListQueryParams,\n    RecordFullListQueryParams,\n} from '@/services/utils/QueryParams';\n\nexport interface RecordAuthResponse<T = Record> {\n    record: T;\n    token:  string;\n    meta?:  {[key: string]: any};\n}\n\nexport interface AuthProviderInfo {\n    name:                string;\n    state:               string;\n    codeVerifier:        string;\n    codeChallenge:       string;\n    codeChallengeMethod: string;\n    authUrl:             string;\n}\n\nexport interface AuthMethodsList {\n    usernamePassword: boolean;\n    emailPassword:    boolean;\n    authProviders:    Array<AuthProviderInfo>;\n}\n\nexport interface RecordSubscription<T = Record> {\n    action: string; // eg. create, update, delete\n    record: T;\n}\n\nexport type OAuth2UrlCallback = (url: string) => void|Promise<void>;\n\nexport interface OAuth2AuthConfig {\n    // the name of the OAuth2 provider (eg. \"google\")\n    provider: string;\n\n    // custom scopes to overwrite the default ones\n    scopes?: Array<string>;\n\n    // optional record create data\n    createData?: {[key: string]: any};\n\n    // optional callback that is triggered after the OAuth2 sign-in/sign-up url generation\n    urlCallback?: OAuth2UrlCallback;\n\n    // optional query params to send with the PocketBase auth request (eg. fields, expand, etc.)\n    query?: RecordQueryParams;\n\n    // optional body params to send with the PocketBase auth request\n    body?: {[key: string]: any};\n}\n\nexport default class RecordService extends CrudService<Record> {\n    readonly collectionIdOrName: string;\n\n    constructor(client: Client, collectionIdOrName: string) {\n        super(client);\n\n        this.collectionIdOrName = collectionIdOrName;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    decode<T = Record>(data: { [key: string]: any }): T {\n        return new Record(data) as any as T;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return this.baseCollectionPath + '/records';\n    }\n\n    /**\n     * Returns the current collection service base path.\n     */\n    get baseCollectionPath(): string {\n        return '/api/collections/' + encodeURIComponent(this.collectionIdOrName);\n    }\n\n    // ---------------------------------------------------------------\n    // Realtime handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * @deprecated Use subscribe(recordId, callback) instead.\n     *\n     * Subscribe to the realtime changes of a single record in the collection.\n     */\n    async subscribeOne<T = Record>(recordId: string, callback: (data: RecordSubscription<T>) => void): Promise<UnsubscribeFunc> {\n        console.warn(\"PocketBase: subscribeOne(recordId, callback) is deprecated. Please replace it with subscribe(recordId, callback).\");\n        return this.client.realtime.subscribe(this.collectionIdOrName + \"/\" + recordId, callback);\n    }\n\n    /**\n     * @deprecated This form of subscribe is deprecated. Please use `subscribe(\"*\", callback)`.\n     */\n    async subscribe<T = Record>(callback: (data: RecordSubscription<T>) => void): Promise<UnsubscribeFunc>\n\n    /**\n     * Subscribe to realtime changes to the specified topic (\"*\" or record id).\n     *\n     * If `topic` is the wildcard \"*\", then this method will subscribe to\n     * any record changes in the collection.\n     *\n     * If `topic` is a record id, then this method will subscribe only\n     * to changes of the specified record id.\n     *\n     * It's OK to subscribe multiple times to the same topic.\n     * You can use the returned `UnsubscribeFunc` to remove only a single subscription.\n     * Or use `unsubscribe(topic)` if you want to remove all subscriptions attached to the topic.\n     */\n    async subscribe<T = Record>(topic: string, callback: (data: RecordSubscription<T>) => void): Promise<UnsubscribeFunc>\n\n    async subscribe<T = Record>(\n        topicOrCallback: string|((data: RecordSubscription<T>) => void),\n        callback?: (data: RecordSubscription<T>) => void\n    ): Promise<UnsubscribeFunc> {\n        if (typeof topicOrCallback === 'function') {\n            console.warn(\"PocketBase: subscribe(callback) is deprecated. Please replace it with subscribe('*', callback).\");\n            return this.client.realtime.subscribe(this.collectionIdOrName, topicOrCallback);\n        }\n\n        if (!callback) {\n            throw new Error(\"Missing subscription callback.\");\n        }\n\n        if (topicOrCallback === \"\") {\n            throw new Error(\"Missing topic.\");\n        }\n\n        let topic = this.collectionIdOrName;\n        if (topicOrCallback !== \"*\") {\n            topic += ('/' + topicOrCallback);\n        }\n\n        return this.client.realtime.subscribe(topic, callback)\n    }\n\n    /**\n     * Unsubscribe from all subscriptions of the specified topic\n     * (\"*\" or record id).\n     *\n     * If `topic` is not set, then this method will unsubscribe from\n     * all subscriptions associated to the current collection.\n     */\n    async unsubscribe(topic?: string): Promise<void> {\n        // unsubscribe wildcard topic\n        if (topic === \"*\") {\n            return this.client.realtime.unsubscribe(this.collectionIdOrName);\n        }\n\n        // unsubscribe recordId topic\n        if (topic) {\n            return this.client.realtime.unsubscribe(this.collectionIdOrName + \"/\" + topic);\n        }\n\n        // unsubscribe from everything related to the collection\n        return this.client.realtime.unsubscribeByPrefix(this.collectionIdOrName);\n    }\n\n    // ---------------------------------------------------------------\n    // Crud handers\n    // ---------------------------------------------------------------\n    /**\n     * @inheritdoc\n     */\n    getFullList<T = Record>(queryParams?: RecordFullListQueryParams): Promise<Array<T>>\n\n    /**\n     * @inheritdoc\n     */\n    getFullList<T = Record>(batch?: number, queryParams?: RecordListQueryParams): Promise<Array<T>>\n\n    /**\n     * @inheritdoc\n     */\n    getFullList<T = Record>(batchOrQueryParams?: number|RecordFullListQueryParams, queryParams?: RecordListQueryParams): Promise<Array<T>> {\n        if (typeof batchOrQueryParams == \"number\") {\n            return super.getFullList<T>(batchOrQueryParams, queryParams);\n        }\n\n        const params = Object.assign({}, batchOrQueryParams, queryParams);\n\n        return super.getFullList<T>(params);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    getList<T = Record>(page = 1, perPage = 30, queryParams: RecordListQueryParams = {}): Promise<ListResult<T>> {\n        return super.getList<T>(page, perPage, queryParams);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    getFirstListItem<T = Record>(filter: string, queryParams: RecordListQueryParams = {}): Promise<T> {\n        return super.getFirstListItem<T>(filter, queryParams);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    getOne<T = Record>(id: string, queryParams: RecordQueryParams = {}): Promise<T> {\n        return super.getOne<T>(id, queryParams);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    create<T = Record>(bodyParams = {}, queryParams: RecordQueryParams = {}): Promise<T> {\n        return super.create<T>(bodyParams, queryParams);\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the updated id, then\n     * on success the `client.authStore.model` will be updated with the result.\n     */\n    update<T = Record>(id: string, bodyParams = {}, queryParams: RecordQueryParams = {}): Promise<T> {\n        return super.update<Record>(id, bodyParams, queryParams).then((item) => {\n            if (\n                // is record auth\n                this.client.authStore.model?.id === item?.id &&\n                (\n                    this.client.authStore.model?.collectionId === this.collectionIdOrName ||\n                    this.client.authStore.model?.collectionName === this.collectionIdOrName\n                )\n            ) {\n                this.client.authStore.save(this.client.authStore.token, item);\n            }\n\n            return item as any as T;\n        });\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the deleted id,\n     * then on success the `client.authStore` will be cleared.\n     */\n    delete(id: string, queryParams: BaseQueryParams = {}): Promise<boolean> {\n        return super.delete(id, queryParams).then((success) => {\n            if (\n                success &&\n                // is record auth\n                this.client.authStore.model?.id === id &&\n                (\n                    this.client.authStore.model?.collectionId === this.collectionIdOrName ||\n                    this.client.authStore.model?.collectionName === this.collectionIdOrName\n                )\n            ) {\n                this.client.authStore.clear();\n            }\n\n            return success;\n        });\n    }\n\n    // ---------------------------------------------------------------\n    // Auth handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * Prepare successful collection authorization response.\n     */\n    protected authResponse<T = Record>(responseData: any): RecordAuthResponse<T> {\n        const record = this.decode(responseData?.record || {});\n\n        this.client.authStore.save(responseData?.token, record);\n\n        return Object.assign({}, responseData, {\n            // normalize common fields\n            'token':  responseData?.token || '',\n            'record': record as any as T,\n        });\n    }\n\n    /**\n     * Returns all available collection auth methods.\n     */\n    listAuthMethods(queryParams: BaseQueryParams = {}): Promise<AuthMethodsList> {\n        return this.client.send(this.baseCollectionPath + '/auth-methods', {\n            'method': 'GET',\n            'params': queryParams,\n        }).then((responseData: any) => {\n            return Object.assign({}, responseData, {\n                // normalize common fields\n                'usernamePassword': !!responseData?.usernamePassword,\n                'emailPassword':    !!responseData?.emailPassword,\n                'authProviders':    Array.isArray(responseData?.authProviders) ? responseData?.authProviders : [],\n            });\n        });\n    }\n\n    /**\n     * Authenticate a single auth collection record via its username/email and password.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     */\n    authWithPassword<T = Record>(\n        usernameOrEmail: string,\n        password: string,\n        bodyParams = {},\n        queryParams: RecordQueryParams = {},\n    ): Promise<RecordAuthResponse<T>> {\n        bodyParams = Object.assign({\n            'identity': usernameOrEmail,\n            'password': password,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/auth-with-password', {\n            'method':  'POST',\n            'params':  queryParams,\n            'body':    bodyParams,\n        }).then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * Authenticate a single auth collection record with OAuth2 code.\n     *\n     * If you don't have an OAuth2 code you may also want to check `authWithOAuth2` method.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     * - the OAuth2 account data (eg. name, email, avatar, etc.)\n     */\n    authWithOAuth2Code<T = Record>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectUrl: string,\n        createData = {},\n        bodyParams = {},\n        queryParams: RecordQueryParams = {},\n    ): Promise<RecordAuthResponse<T>> {\n        bodyParams = Object.assign({\n            'provider':     provider,\n            'code':         code,\n            'codeVerifier': codeVerifier,\n            'redirectUrl':  redirectUrl,\n            'createData':  createData,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/auth-with-oauth2', {\n            'method':  'POST',\n            'params':  queryParams,\n            'body':    bodyParams,\n        }).then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * @deprecated This form of authWithOAuth2 is deprecated.\n     *\n     * Please use `authWithOAuth2Code()` OR its simplified realtime version\n     * as shown in https://pocketbase.io/docs/authentication/#oauth2-integration.\n     */\n    async authWithOAuth2<T = Record>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectUrl: string,\n        createData?: {[key: string]: any},\n        bodyParams?: {[key: string]: any},\n        queryParams?: RecordQueryParams,\n    ): Promise<RecordAuthResponse<T>>\n\n    /**\n     * Authenticate a single auth collection record with OAuth2\n     * **without custom redirects, deeplinks or even page reload**.\n     *\n     * This method initializes a one-off realtime subscription and will\n     * open a popup window with the OAuth2 vendor page to authenticate.\n     * Once the external OAuth2 sign-in/sign-up flow is completed, the popup\n     * window will be automatically closed and the OAuth2 data sent back\n     * to the user through the previously established realtime connection.\n     *\n     * You can specify an optional `urlCallback` prop to customize\n     * the default url `window.open` behavior.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     * - the OAuth2 account data (eg. name, email, avatar, etc.)\n     *\n     * Example:\n     *\n     * ```js\n     * const authData = await pb.collection(\"users\").authWithOAuth2({\n     *     provider: \"google\",\n     * })\n     * ```\n     *\n     * _Site-note_: when creating the OAuth2 app in the provider dashboard\n     * you have to configure `https://yourdomain.com/api/oauth2-redirect`\n     * as redirect URL.\n     */\n    async authWithOAuth2<T = Record>(options: OAuth2AuthConfig): Promise<RecordAuthResponse<T>>\n\n    async authWithOAuth2<T = Record>(...args: any): Promise<RecordAuthResponse<T>> {\n        // fallback to legacy format\n        if (args.length > 1 || typeof args?.[0] === 'string') {\n            console.warn(\"PocketBase: This form of authWithOAuth2() is deprecated and may get removed in the future. Please replace with authWithOAuth2Code() OR use the authWithOAuth2() realtime form as shown in https://pocketbase.io/docs/authentication/#oauth2-integration.\");\n            return this.authWithOAuth2Code<T>(\n                args?.[0] || '',\n                args?.[1] || '',\n                args?.[2] || '',\n                args?.[3] || '',\n                args?.[4] || {},\n                args?.[5] || {},\n                args?.[6] || {},\n            );\n        }\n\n        const config = args?.[0] || {};\n\n        const authMethods = await this.listAuthMethods();\n\n        const provider = authMethods.authProviders.find((p) => p.name === config.provider);\n        if (!provider) {\n            throw new ClientResponseError(new Error(`Missing or invalid provider \"${config.provider}\".`));\n        }\n\n        const redirectUrl = this.client.buildUrl('/api/oauth2-redirect');\n\n        return new Promise(async (resolve, reject) => {\n            try {\n                // initialize a one-off @oauth2 realtime subscription\n                const unsubscribe = await this.client.realtime.subscribe('@oauth2', async (e) => {\n                    const oldState = this.client.realtime.clientId;\n\n                    try {\n                        unsubscribe();\n\n                        if (!e.state || oldState !== e.state) {\n                            throw new Error(\"State parameters don't match.\");\n                        }\n\n                        const authData = await this.authWithOAuth2Code<T>(\n                            provider.name,\n                            e.code,\n                            provider.codeVerifier,\n                            redirectUrl,\n                            config.createData,\n                            config.body,\n                            config.query,\n                        )\n\n                        resolve(authData);\n                    } catch (err) {\n                        reject(new ClientResponseError(err));\n                    }\n                });\n\n                const replacements: {[key: string]: any} = {\n                    \"state\": this.client.realtime.clientId,\n                }\n                if (config.scopes?.length) {\n                    replacements[\"scope\"] = config.scopes.join(\" \");\n                }\n\n                const url = this._replaceQueryParams(provider.authUrl + redirectUrl, replacements);\n\n                await (config.urlCallback ? config.urlCallback(url) : this._defaultUrlCallback(url));\n            } catch (err) {\n                reject(new ClientResponseError(err));\n            }\n        });\n    }\n\n    /**\n     * Refreshes the current authenticated record instance and\n     * returns a new token and record data.\n     *\n     * On success this method also automatically updates the client's AuthStore.\n     */\n    authRefresh<T = Record>(bodyParams = {}, queryParams: RecordQueryParams = {}): Promise<RecordAuthResponse<T>> {\n        return this.client.send(this.baseCollectionPath + '/auth-refresh', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * Sends auth record password reset request.\n     */\n    requestPasswordReset(\n        email: string,\n        bodyParams  = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'email': email,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/request-password-reset', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Confirms auth record password reset request.\n     */\n    confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        bodyParams = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'token':           passwordResetToken,\n            'password':        password,\n            'passwordConfirm': passwordConfirm,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/confirm-password-reset', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Sends auth record verification email request.\n     */\n    requestVerification(\n        email: string,\n        bodyParams = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'email': email,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/request-verification', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Confirms auth record email verification request.\n     */\n    confirmVerification(\n        verificationToken: string,\n        bodyParams  = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'token': verificationToken,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/confirm-verification', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Sends an email change request to the authenticated record model.\n     */\n    requestEmailChange(\n        newEmail: string,\n        bodyParams = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'newEmail': newEmail,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/request-email-change', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Confirms auth record's new email address.\n     */\n    confirmEmailChange(\n        emailChangeToken: string,\n        password: string,\n        bodyParams  = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'token': emailChangeToken,\n            'password': password,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/confirm-email-change', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Lists all linked external auth providers for the specified auth record.\n     */\n    listExternalAuths(\n        recordId: string,\n        queryParams: BaseQueryParams = {}\n    ): Promise<Array<ExternalAuth>> {\n        return this.client.send(this.baseCrudPath + '/' + encodeURIComponent(recordId) + '/external-auths', {\n            'method': 'GET',\n            'params': queryParams,\n        }).then((responseData) => {\n            const items: Array<ExternalAuth> = [];\n\n            if (Array.isArray(responseData)) {\n                for (const item of responseData) {\n                    items.push(new ExternalAuth(item));\n                }\n            }\n\n            return items;\n        });\n    }\n\n    /**\n     * Unlink a single external auth provider from the specified auth record.\n     */\n    unlinkExternalAuth(\n        recordId: string,\n        provider: string,\n        queryParams: BaseQueryParams = {}\n    ): Promise<boolean> {\n        return this.client.send(this.baseCrudPath + '/' + encodeURIComponent(recordId) + '/external-auths/' + encodeURIComponent(provider), {\n            'method': 'DELETE',\n            'params': queryParams,\n        }).then(() => true);\n    }\n\n    // ---------------------------------------------------------------\n\n    // very rudimentary url query params replacement because at the moment\n    // URL (and URLSearchParams) doesn't seem to be fully supported in React Native\n    //\n    // note: for details behind some of the decode/encode parsing check https://unixpapa.com/js/querystring.html\n    private _replaceQueryParams(url: string, replacements: {[key: string]: any} = {}): string {\n        let urlPath = url\n        let query = \"\";\n\n        const queryIndex = url.indexOf(\"?\");\n        if (queryIndex >= 0) {\n            urlPath = url.substring(0, url.indexOf(\"?\"));\n            query = url.substring(url.indexOf(\"?\") + 1);\n        }\n\n        const parsedParams: {[key: string]: string} = {};\n\n        // parse the query parameters\n        const rawParams = query.split(\"&\");\n        for (const param of rawParams) {\n            if (param == \"\") {\n                continue\n            }\n\n            const pair = param.split(\"=\");\n            parsedParams[decodeURIComponent(pair[0].replace(/\\+/g,' '))] = decodeURIComponent((pair[1] || \"\").replace(/\\+/g,' '));\n        }\n\n        // apply the replacements\n        for (let key in replacements) {\n            if (!replacements.hasOwnProperty(key)) {\n                continue;\n            }\n\n            if (replacements[key] == null) {\n                delete parsedParams[key];\n            } else {\n                parsedParams[key] = replacements[key];\n            }\n        }\n\n        // construct back the full query string\n        query = \"\";\n        for (let key in parsedParams) {\n            if (!parsedParams.hasOwnProperty(key)) {\n                continue;\n            }\n\n            if (query != \"\") {\n                query += \"&\";\n            }\n\n            query += encodeURIComponent(key.replace(/%20/g,'+')) + \"=\" + encodeURIComponent(parsedParams[key].replace(/%20/g,'+'));\n        }\n\n        return query != \"\" ? (urlPath + \"?\" + query) : urlPath;\n    }\n\n    private _defaultUrlCallback(url: string) {\n        if (typeof window === \"undefined\" || !window?.open) {\n            throw new ClientResponseError(new Error(`Not in a browser context - please pass a custom urlCallback function.`));\n        }\n\n        let width  = 1024;\n        let height = 768;\n\n        let windowWidth  = window.innerWidth;\n        let windowHeight = window.innerHeight;\n\n        // normalize window size\n        width  = width > windowWidth ? windowWidth : width;\n        height = height > windowHeight ? windowHeight : height;\n\n        let left = (windowWidth / 2) - (width / 2);\n        let top  = (windowHeight / 2) - (height / 2);\n\n        window.open(\n            url,\n            \"oauth2-popup\",\n            'width='+width+',height='+height+',top='+top+',left='+left+',resizable,menubar=no'\n        );\n    }\n}\n","export default class SchemaField {\n    id!:       string;\n    name!:     string;\n    type!:     string;\n    system!:   boolean;\n    required!: boolean;\n    options!:  { [key: string]: any };\n\n    constructor(data: { [key: string]: any } = {}) {\n        this.id       = typeof data.id !== 'undefined' ? data.id : '';\n        this.name     = typeof data.name !== 'undefined' ? data.name : '';\n        this.type     = typeof data.type !== 'undefined' ? data.type : 'text';\n        this.system   = !!data.system;\n        this.required = !!data.required;\n        this.options  = typeof data.options === 'object' && data.options !== null ? data.options : {};\n    }\n}\n","import BaseModel   from '@/models/utils/BaseModel';\nimport SchemaField from '@/models/utils/SchemaField';\n\nexport default class Collection extends BaseModel {\n    name!:       string;\n    type!:       string;\n    schema!:     Array<SchemaField>;\n    indexes!:    Array<string>;\n    system!:     boolean;\n    listRule!:   null|string;\n    viewRule!:   null|string;\n    createRule!: null|string;\n    updateRule!: null|string;\n    deleteRule!: null|string;\n    options!:    {[key:string]: any};\n\n    /**\n     * @inheritdoc\n     */\n    $load(data: { [key: string]: any }) {\n        super.$load(data);\n\n        this.system  = !!data.system;\n        this.name    = typeof data.name === 'string' ? data.name : '';\n        this.type    = typeof data.type === 'string' ? data.type : 'base';\n        this.options = typeof data.options !== 'undefined' && data.options !== null ? data.options : {};\n        this.indexes = Array.isArray(data.indexes) ? data.indexes : [];\n\n        // rules\n        this.listRule   = typeof data.listRule   === 'string' ? data.listRule   : null;\n        this.viewRule   = typeof data.viewRule   === 'string' ? data.viewRule   : null;\n        this.createRule = typeof data.createRule === 'string' ? data.createRule : null;\n        this.updateRule = typeof data.updateRule === 'string' ? data.updateRule : null;\n        this.deleteRule = typeof data.deleteRule === 'string' ? data.deleteRule : null;\n\n        // schema\n        data.schema = Array.isArray(data.schema) ? data.schema : [];\n        this.schema = [];\n        for (let field of data.schema) {\n            this.schema.push(new SchemaField(field));\n        }\n    }\n\n    /**\n     * @deprecated Please use $isBase instead.\n     */\n    get isBase(): boolean {\n        return this.$isBase;\n    }\n\n    /**\n     * Checks if the current model is \"base\" collection.\n     */\n    get $isBase(): boolean {\n        return this.type === 'base';\n    }\n\n    /**\n     * @deprecated Please use $isAuth instead.\n     */\n    get isAuth(): boolean {\n        return this.$isAuth;\n    }\n\n    /**\n     * Checks if the current model is \"auth\" collection.\n     */\n    get $isAuth(): boolean {\n        return this.type === 'auth';\n    }\n\n    /**\n     * @deprecated Please use $isView instead.\n     */\n    get isView(): boolean {\n        return this.$isView;\n    }\n\n    /**\n     * Checks if the current model is \"view\" collection.\n     */\n    get $isView(): boolean {\n        return this.type === 'view';\n    }\n}\n","import Collection          from '@/models/Collection';\nimport CrudService         from '@/services/utils/CrudService';\nimport { BaseQueryParams } from '@/services/utils/QueryParams';\n\nexport default class CollectionService extends CrudService<Collection> {\n    /**\n     * @inheritdoc\n     */\n    decode(data: { [key: string]: any }): Collection {\n        return new Collection(data);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return '/api/collections';\n    }\n\n    /**\n     * Imports the provided collections.\n     *\n     * If `deleteMissing` is `true`, all local collections and schema fields,\n     * that are not present in the imported configuration, WILL BE DELETED\n     * (including their related records data)!\n     */\n    async import(\n        collections: Array<Collection>,\n        deleteMissing: boolean = false,\n        queryParams: BaseQueryParams = {}\n    ): Promise<true> {\n        return this.client.send(this.baseCrudPath + '/import', {\n            'method': 'PUT',\n            'params': queryParams,\n            'body': {\n                'collections':  collections,\n                'deleteMissing': deleteMissing,\n            }\n        }).then(() => true);\n    }\n}\n","import BaseModel from '@/models/utils/BaseModel';\n\nexport default class LogRequest extends BaseModel {\n    url!:       string;\n    method!:    string;\n    status!:    number;\n    auth!:      string;\n    remoteIp!:  string;\n    userIp!:    string;\n    referer!:   string;\n    userAgent!: string;\n    meta!:      { [key: string]: any };\n\n    /**\n     * @inheritdoc\n     */\n    $load(data: { [key: string]: any }) {\n        super.$load(data);\n\n        // fallback to the ip field for backward compatibility\n        data.remoteIp = data.remoteIp || data.ip;\n\n        this.url       = typeof data.url       === 'string' ? data.url       : '';\n        this.method    = typeof data.method    === 'string' ? data.method    : 'GET';\n        this.status    = typeof data.status    === 'number' ? data.status    : 200;\n        this.auth      = typeof data.auth      === 'string' ? data.auth      : 'guest';\n        this.remoteIp  = typeof data.remoteIp  === 'string' ? data.remoteIp  : '';\n        this.userIp    = typeof data.userIp    === 'string' ? data.userIp    : '';\n        this.referer   = typeof data.referer   === 'string' ? data.referer   : '';\n        this.userAgent = typeof data.userAgent === 'string' ? data.userAgent : '';\n        this.meta      = typeof data.meta === 'object' && data.meta !== null ? data.meta : {};\n    }\n}\n","import LogRequest  from '@/models/LogRequest';\nimport ListResult  from '@/models/utils/ListResult';\nimport BaseService from '@/services/utils/BaseService';\nimport {\n    BaseQueryParams,\n    ListQueryParams,\n    LogStatsQueryParams,\n} from '@/services/utils/QueryParams';\n\nexport interface HourlyStats {\n    total: number;\n    date:  string;\n}\n\nexport default class LogService extends BaseService {\n    /**\n     * Returns paginated logged requests list.\n     */\n    getRequestsList(page = 1, perPage = 30, queryParams: ListQueryParams = {}): Promise<ListResult<LogRequest>> {\n        queryParams = Object.assign({\n            'page':    page,\n            'perPage': perPage,\n        }, queryParams);\n\n        return this.client.send('/api/logs/requests', {\n            'method': 'GET',\n            'params': queryParams,\n        }).then((responseData: any) => {\n            const items: Array<LogRequest> = [];\n            if (responseData?.items) {\n                responseData.items = responseData?.items || [];\n                for (const item of responseData.items) {\n                    items.push(new LogRequest(item));\n                }\n            }\n\n            return new ListResult<LogRequest>(\n                responseData?.page || 1,\n                responseData?.perPage || 0,\n                responseData?.totalItems || 0,\n                responseData?.totalPages || 0,\n                items,\n            );\n        });\n    }\n\n    /**\n     * Returns a single logged request by its id.\n     */\n    getRequest(id: string, queryParams: BaseQueryParams = {}): Promise<LogRequest> {\n        return this.client.send('/api/logs/requests/' + encodeURIComponent(id), {\n            'method': 'GET',\n            'params': queryParams\n        }).then((responseData: any) => new LogRequest(responseData));\n    }\n\n    /**\n     * Returns request logs statistics.\n     */\n    getRequestsStats(queryParams: LogStatsQueryParams = {}): Promise<Array<HourlyStats>> {\n        return this.client.send('/api/logs/requests/stats', {\n            'method': 'GET',\n            'params': queryParams\n        }).then((responseData: any) => responseData);\n    }\n}\n","import BaseService from '@/services/utils/BaseService';\nimport ClientResponseError from '@/ClientResponseError';\n\ninterface promiseCallbacks {\n    resolve: Function\n    reject: Function\n}\n\nexport type UnsubscribeFunc = () => Promise<void>;\n\nexport default class RealtimeService extends BaseService {\n    clientId: string = \"\";\n\n    private eventSource: EventSource | null = null;\n    private subscriptions: { [key: string]: Array<EventListener> } = {};\n    private lastSentTopics: Array<string> = [];\n    private connectTimeoutId: any;\n    private maxConnectTimeout: number = 15000;\n    private reconnectTimeoutId: any;\n    private reconnectAttempts: number = 0;\n    private maxReconnectAttempts: number = Infinity;\n    private predefinedReconnectIntervals: Array<number> = [\n        200, 300, 500, 1000, 1200, 1500, 2000,\n    ];\n    private pendingConnects: Array<promiseCallbacks> = [];\n\n\n    /**\n     * Returns whether the realtime connection has been established.\n     */\n    get isConnected(): boolean {\n        return !!this.eventSource && !!this.clientId && !this.pendingConnects.length;\n    }\n\n    /**\n     * Register the subscription listener.\n     *\n     * You can subscribe multiple times to the same topic.\n     *\n     * If the SSE connection is not started yet,\n     * this method will also initialize it.\n     */\n    async subscribe(topic: string, callback: (data: any) => void): Promise<UnsubscribeFunc> {\n        if (!topic) {\n            throw new Error('topic must be set.')\n        }\n\n        const listener = function (e: Event) {\n            const msgEvent = (e as MessageEvent);\n\n            let data;\n            try {\n                data = JSON.parse(msgEvent?.data);\n            } catch {}\n\n            callback(data || {});\n        };\n\n        // store the listener\n        if (!this.subscriptions[topic]) {\n            this.subscriptions[topic] = [];\n        }\n        this.subscriptions[topic].push(listener);\n\n        if (!this.isConnected) {\n            // initialize sse connection\n            await this.connect();\n        } else if (this.subscriptions[topic].length === 1) {\n            // send the updated subscriptions (if it is the first for the topic)\n            await this.submitSubscriptions();\n        } else {\n            // only register the listener\n            this.eventSource?.addEventListener(topic, listener);\n        }\n\n        return async (): Promise<void> => {\n            return this.unsubscribeByTopicAndListener(topic, listener);\n        };\n    }\n\n    /**\n     * Unsubscribe from all subscription listeners with the specified topic.\n     *\n     * If `topic` is not provided, then this method will unsubscribe\n     * from all active subscriptions.\n     *\n     * This method is no-op if there are no active subscriptions.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribe(topic?: string): Promise<void> {\n        if (!this.hasSubscriptionListeners(topic)) {\n            return; // already unsubscribed\n        }\n\n        if (!topic) {\n            // remove all subscriptions\n            this.subscriptions = {};\n        } else {\n            // remove all topic listeners\n            for (let listener of this.subscriptions[topic]) {\n                this.eventSource?.removeEventListener(topic, listener);\n            }\n            delete this.subscriptions[topic];\n        }\n\n        if (!this.hasSubscriptionListeners()) {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        } else if (!this.hasSubscriptionListeners(topic)) {\n            // submit subscriptions change if there are no other active subscriptions related to the topic\n            await this.submitSubscriptions();\n        }\n    }\n\n    /**\n     * Unsubscribe from all subscription listeners starting with the specified topic prefix.\n     *\n     * This method is no-op if there are no active subscriptions with the specified topic prefix.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribeByPrefix(topicPrefix: string): Promise<void> {\n        let hasAtleastOneTopic = false;\n        for (let topic in this.subscriptions) {\n            if (!topic.startsWith(topicPrefix)) {\n                continue;\n            }\n\n            hasAtleastOneTopic = true;\n            for (let listener of this.subscriptions[topic]) {\n                this.eventSource?.removeEventListener(topic, listener);\n            }\n            delete this.subscriptions[topic];\n        }\n\n        if (!hasAtleastOneTopic) {\n            return; // nothing to unsubscribe from\n        }\n\n        if (this.hasSubscriptionListeners()) {\n            // submit the deleted subscriptions\n            await this.submitSubscriptions();\n        } else {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        }\n    }\n\n    /**\n     * Unsubscribe from all subscriptions matching the specified topic and listener function.\n     *\n     * This method is no-op if there are no active subscription with\n     * the specified topic and listener.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribeByTopicAndListener(topic: string, listener: EventListener): Promise<void> {\n        if (!Array.isArray(this.subscriptions[topic]) || !this.subscriptions[topic].length) {\n            return; // already unsubscribed\n        }\n\n        let exist = false;\n        for (let i = this.subscriptions[topic].length - 1; i >= 0; i--) {\n            if (this.subscriptions[topic][i] !== listener) {\n                continue;\n            }\n\n            exist = true;                           // has at least one matching listener\n            delete this.subscriptions[topic][i];    // removes the function reference\n            this.subscriptions[topic].splice(i, 1); // reindex the array\n            this.eventSource?.removeEventListener(topic, listener);\n        }\n        if (!exist) {\n            return;\n        }\n\n        // remove the topic from the subscriptions list if there are no other listeners\n        if (!this.subscriptions[topic].length) {\n            delete this.subscriptions[topic];\n        }\n\n        if (!this.hasSubscriptionListeners()) {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        } else if (!this.hasSubscriptionListeners(topic)) {\n            // submit subscriptions change if there are no other active subscriptions related to the topic\n            await this.submitSubscriptions();\n        }\n    }\n\n    private hasSubscriptionListeners(topicToCheck?: string): boolean {\n        this.subscriptions = this.subscriptions || {};\n\n        // check the specified topic\n        if (topicToCheck) {\n            return !!this.subscriptions[topicToCheck]?.length;\n        }\n\n        // check for at least one non-empty topic\n        for (let topic in this.subscriptions) {\n            if (!!this.subscriptions[topic]?.length) {\n                return true\n            }\n        }\n\n        return false;\n    }\n\n    private async submitSubscriptions(): Promise<void> {\n        if (!this.clientId) {\n            return; // no client/subscriber\n        }\n\n        // optimistic update\n        this.addAllSubscriptionListeners();\n\n        this.lastSentTopics = this.getNonEmptySubscriptionTopics();\n\n        return this.client.send('/api/realtime', {\n            'method': 'POST',\n            'body': {\n                'clientId': this.clientId,\n                'subscriptions': this.lastSentTopics,\n            },\n            'params': {\n                '$cancelKey': this.getSubscriptionsCancelKey(),\n            },\n        }).catch((err) => {\n            if (err?.isAbort) {\n                return; // silently ignore aborted pending requests\n            }\n            throw err;\n        });\n    }\n\n    private getSubscriptionsCancelKey(): string {\n        return \"realtime_\" + this.clientId;\n    }\n\n    private getNonEmptySubscriptionTopics(): Array<string> {\n        const result : Array<string> = [];\n\n        for (let topic in this.subscriptions) {\n            if (this.subscriptions[topic].length) {\n                result.push(topic);\n            }\n        }\n\n        return result;\n    }\n\n    private addAllSubscriptionListeners(): void {\n        if (!this.eventSource) {\n            return;\n        }\n\n        this.removeAllSubscriptionListeners();\n\n        for (let topic in this.subscriptions) {\n            for (let listener of this.subscriptions[topic]) {\n                this.eventSource.addEventListener(topic, listener);\n            }\n        }\n    }\n\n    private removeAllSubscriptionListeners(): void {\n        if (!this.eventSource) {\n            return;\n        }\n\n        for (let topic in this.subscriptions) {\n            for (let listener of this.subscriptions[topic]) {\n                this.eventSource.removeEventListener(topic, listener);\n            }\n        }\n    }\n\n    private async connect(): Promise<void> {\n        if (this.reconnectAttempts > 0)  {\n            // immediately resolve the promise to avoid indefinitely\n            // blocking the client during reconnection\n            return;\n        }\n\n        return new Promise((resolve, reject) => {\n            this.pendingConnects.push({ resolve, reject });\n\n            if (this.pendingConnects.length > 1) {\n                // all promises will be resolved once the connection is established\n                return;\n            }\n\n            this.initConnect();\n        })\n    }\n\n    private initConnect() {\n        this.disconnect(true);\n\n        // wait up to 15s for connect\n        clearTimeout(this.connectTimeoutId);\n        this.connectTimeoutId = setTimeout(() => {\n            this.connectErrorHandler(new Error(\"EventSource connect took too long.\"));\n        }, this.maxConnectTimeout);\n\n        this.eventSource = new EventSource(this.client.buildUrl('/api/realtime'))\n\n        this.eventSource.onerror = (_) => {\n            this.connectErrorHandler(new Error(\"Failed to establish realtime connection.\"));\n        };\n\n        this.eventSource.addEventListener('PB_CONNECT', (e) => {\n            const msgEvent = (e as MessageEvent);\n            this.clientId = msgEvent?.lastEventId;\n\n            this.submitSubscriptions()\n            .then(async () => {\n                let retries = 3;\n                while (this.hasUnsentSubscriptions() && retries > 0) {\n                    retries--;\n                    // resubscribe to ensure that the latest topics are submitted\n                    //\n                    // This is needed because missed topics could happen on reconnect\n                    // if after the pending sent `submitSubscriptions()` call another `subscribe()`\n                    // was made before the submit was able to complete.\n                    await this.submitSubscriptions();\n                }\n            }).then(() => {\n                for (let p of this.pendingConnects) {\n                    p.resolve();\n                }\n\n                // reset connect meta\n                this.pendingConnects = [];\n                this.reconnectAttempts = 0;\n                clearTimeout(this.reconnectTimeoutId);\n                clearTimeout(this.connectTimeoutId);\n            }).catch((err) => {\n                this.clientId = \"\";\n                this.connectErrorHandler(err);\n            });\n        });\n    }\n\n    private hasUnsentSubscriptions(): boolean {\n        const latestTopics = this.getNonEmptySubscriptionTopics();\n        if (latestTopics.length != this.lastSentTopics.length) {\n            return true;\n        }\n\n        for (const t of latestTopics) {\n            if (!this.lastSentTopics.includes(t)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private connectErrorHandler(err: any) {\n        clearTimeout(this.connectTimeoutId);\n        clearTimeout(this.reconnectTimeoutId);\n\n        if (\n            // wasn't previously connected -> direct reject\n            (!this.clientId && !this.reconnectAttempts) ||\n            // was previously connected but the max reconnection limit has been reached\n            this.reconnectAttempts > this.maxReconnectAttempts\n        ) {\n            for (let p of this.pendingConnects) {\n                p.reject(new ClientResponseError(err));\n            }\n            this.disconnect();\n            return;\n        }\n\n        // otherwise -> reconnect in the background\n        this.disconnect(true);\n        const timeout = this.predefinedReconnectIntervals[this.reconnectAttempts] || this.predefinedReconnectIntervals[this.predefinedReconnectIntervals.length - 1];\n        this.reconnectAttempts++;\n        this.reconnectTimeoutId = setTimeout(() => {\n            this.initConnect();\n        }, timeout);\n    }\n\n    private disconnect(fromReconnect = false): void {\n        clearTimeout(this.connectTimeoutId);\n        clearTimeout(this.reconnectTimeoutId);\n        this.removeAllSubscriptionListeners();\n        this.client.cancelRequest(this.getSubscriptionsCancelKey());\n        this.eventSource?.close();\n        this.eventSource = null;\n        this.clientId = \"\";\n\n        if (!fromReconnect) {\n            this.reconnectAttempts = 0;\n\n            // reject any remaining connect promises\n            const err = new ClientResponseError(new Error(\"Realtime disconnected.\"));\n            for (let p of this.pendingConnects) {\n                p.reject(err);\n            }\n            this.pendingConnects = [];\n        }\n    }\n}\n","import BaseService         from '@/services/utils/BaseService';\nimport { BaseQueryParams } from '@/services/utils/QueryParams';\n\nexport interface HealthCheckResponse {\n    code:    number;\n    message: string;\n    data:    {[key: string]: any};\n}\n\nexport default class HealthService extends BaseService {\n    /**\n     * Checks the health status of the api.\n     */\n    check(queryParams: BaseQueryParams = {}): Promise<HealthCheckResponse> {\n        return this.client.send('/api/health', {\n            'method': 'GET',\n            'params': queryParams,\n        });\n    }\n}\n","import BaseService from '@/services/utils/BaseService';\nimport Record      from '@/models/Record';\nimport { BaseQueryParams, FileQueryParams } from '@/services/utils/QueryParams';\n\nexport default class FileService extends BaseService {\n    /**\n     * Builds and returns an absolute record file url for the provided filename.\n     */\n    getUrl(\n        record: Pick<Record, \"id\" | \"collectionId\" | \"collectionName\">,\n        filename: string,\n        queryParams: FileQueryParams = {}\n    ): string {\n        const parts = [];\n        parts.push(\"api\")\n        parts.push(\"files\")\n        parts.push(encodeURIComponent(record.collectionId || record.collectionName))\n        parts.push(encodeURIComponent(record.id))\n        parts.push(encodeURIComponent(filename))\n\n        let result = this.client.buildUrl(parts.join('/'));\n\n        if (Object.keys(queryParams).length) {\n            const params = new URLSearchParams(queryParams);\n            result += (result.includes(\"?\") ? \"&\" : \"?\") + params;\n        }\n\n        return result\n    }\n\n    /**\n     * Requests a new private file access token for the current auth model (admin or record).\n     */\n    getToken(queryParams: BaseQueryParams = {}): Promise<string> {\n        return this.client.send('/api/files/token', {\n            'method': 'POST',\n            'params': queryParams,\n        }).then((data) => data?.token || '');\n    }\n}\n","import BaseService         from '@/services/utils/BaseService';\nimport { BaseQueryParams } from '@/services/utils/QueryParams';\n\nexport interface BackupFileInfo {\n    key:      string;\n    size:     number;\n    modified: string;\n}\n\nexport default class BackupService extends BaseService {\n    /**\n     * Returns list with all available backup files.\n     */\n    getFullList(queryParams: BaseQueryParams = {}): Promise<Array<BackupFileInfo>> {\n        return this.client.send('/api/backups', {\n            'method': 'GET',\n            'params': queryParams,\n        });\n    }\n\n    /**\n     * Initializes a new backup.\n     */\n    create(basename: string, queryParams: BaseQueryParams = {}): Promise<boolean> {\n        const bodyParams = {\n            'name': basename,\n        };\n\n        return this.client.send('/api/backups', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Deletes a single backup file.\n     */\n    delete(key: string, queryParams: BaseQueryParams = {}): Promise<boolean> {\n        return this.client.send(`/api/backups/${encodeURIComponent(key)}`, {\n            'method': 'DELETE',\n            'params': queryParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Initializes an app data restore from an existing backup.\n     */\n    restore(key: string, queryParams: BaseQueryParams = {}): Promise<boolean> {\n        return this.client.send(`/api/backups/${encodeURIComponent(key)}/restore`, {\n            'method': 'POST',\n            'params': queryParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Builds a download url for a single existing backup using an\n     * admin file token and the backup file key.\n     *\n     * The file token can be generated via `pb.files.getToken()`.\n     */\n    getDownloadUrl(token: string, key: string): string {\n        return this.client.buildUrl(`/api/backups/${encodeURIComponent(key)}?token=${encodeURIComponent(token)}`);\n    }\n}\n","import ClientResponseError from '@/ClientResponseError';\nimport BaseAuthStore       from '@/stores/BaseAuthStore';\nimport LocalAuthStore      from '@/stores/LocalAuthStore';\nimport SettingsService     from '@/services/SettingsService';\nimport AdminService        from '@/services/AdminService';\nimport RecordService       from '@/services/RecordService';\nimport CollectionService   from '@/services/CollectionService';\nimport LogService          from '@/services/LogService';\nimport RealtimeService     from '@/services/RealtimeService';\nimport HealthService       from '@/services/HealthService';\nimport FileService         from '@/services/FileService';\nimport BackupService       from '@/services/BackupService';\nimport Record              from '@/models/Record';\nimport { BaseQueryParams, FileQueryParams } from '@/services/utils/QueryParams';\n\nexport interface SendOptions extends RequestInit {\n    headers?: { [key: string]: string };\n    body?: any;\n    params?: BaseQueryParams;\n}\n\nexport interface BeforeSendResult {\n    [key: string]: any, // for backward compatibility\n    url?: string,\n    options?: {[key: string]: any}\n}\n\n/**\n * PocketBase JS Client.\n */\nexport default class Client {\n    /**\n     * The base PocketBase backend url address (eg. 'http://127.0.0.1.8090').\n     */\n    baseUrl: string;\n\n    /**\n     * Hook that get triggered right before sending the fetch request,\n     * allowing you to inspect and modify the url and request options.\n     *\n     * For list of the possible options check https://developer.mozilla.org/en-US/docs/Web/API/fetch#options\n     *\n     * You can return a non-empty result object `{ url, options }` to replace the url and request options entirely.\n     *\n     * Example:\n     * ```js\n     * client.beforeSend = function (url, options) {\n     *     options.headers = Object.assign({}, options.headers, {\n     *         'X-Custom-Header': 'example',\n     *     });\n     *\n     *     return { url, options }\n     * };\n     * ```\n     */\n    beforeSend?: (url: string, options: SendOptions) => BeforeSendResult|Promise<BeforeSendResult>;\n\n    /**\n     * Hook that get triggered after successfully sending the fetch request,\n     * allowing you to inspect/modify the response object and its parsed data.\n     *\n     * Returns the new Promise resolved `data` that will be returned to the client.\n     *\n     * Example:\n     * ```js\n     * client.afterSend = function (response, data) {\n     *     if (response.status != 200) {\n     *         throw new ClientResponseError({\n     *             url:      response.url,\n     *             status:   response.status,\n     *             data:     data,\n     *         });\n     *     }\n     *\n     *     return data;\n     * };\n     * ```\n     */\n    afterSend?: (response: Response, data: any) => any;\n\n    /**\n     * Optional language code (default to `en-US`) that will be sent\n     * with the requests to the server as `Accept-Language` header.\n     */\n    lang: string;\n\n    /**\n     * A replaceable instance of the local auth store service.\n     */\n    authStore: BaseAuthStore;\n\n    /**\n     * An instance of the service that handles the **Settings APIs**.\n     */\n    readonly settings: SettingsService;\n\n    /**\n     * An instance of the service that handles the **Admin APIs**.\n     */\n    readonly admins: AdminService;\n\n    /**\n     * An instance of the service that handles the **Collection APIs**.\n     */\n    readonly collections: CollectionService;\n\n    /**\n     * An instance of the service that handles the **File APIs**.\n     */\n    readonly files: FileService;\n\n    /**\n     * An instance of the service that handles the **Log APIs**.\n     */\n    readonly logs: LogService;\n\n    /**\n     * An instance of the service that handles the **Realtime APIs**.\n     */\n    readonly realtime: RealtimeService;\n\n    /**\n     * An instance of the service that handles the **Health APIs**.\n     */\n    readonly health: HealthService;\n\n    /**\n     * An instance of the service that handles the **Backup APIs**.\n     */\n    readonly backups: BackupService;\n\n    private cancelControllers: { [key: string]: AbortController } = {};\n    private recordServices: { [key: string]: RecordService } = {};\n    private enableAutoCancellation: boolean = true;\n\n    constructor(\n        baseUrl = '/',\n        authStore?: BaseAuthStore | null,\n        lang = 'en-US',\n    ) {\n        this.baseUrl   = baseUrl;\n        this.lang      = lang;\n        this.authStore = authStore || new LocalAuthStore();\n\n        // services\n        this.admins      = new AdminService(this);\n        this.collections = new CollectionService(this);\n        this.files       = new FileService(this);\n        this.logs        = new LogService(this);\n        this.settings    = new SettingsService(this);\n        this.realtime    = new RealtimeService(this);\n        this.health      = new HealthService(this);\n        this.backups     = new BackupService(this);\n    }\n\n    /**\n     * Returns the RecordService associated to the specified collection.\n     *\n     * @param  {string} idOrName\n     * @return {RecordService}\n     */\n    collection(idOrName: string): RecordService {\n        if (!this.recordServices[idOrName]) {\n            this.recordServices[idOrName] = new RecordService(this, idOrName);\n        }\n\n        return this.recordServices[idOrName];\n    }\n\n    /**\n     * Globally enable or disable auto cancellation for pending duplicated requests.\n     */\n    autoCancellation(enable: boolean): Client {\n        this.enableAutoCancellation = !!enable;\n\n        return this;\n    }\n\n    /**\n     * Cancels single request by its cancellation key.\n     */\n    cancelRequest(cancelKey: string): Client {\n        if (this.cancelControllers[cancelKey]) {\n            this.cancelControllers[cancelKey].abort();\n            delete this.cancelControllers[cancelKey];\n        }\n\n        return this;\n    }\n\n    /**\n     * Cancels all pending requests.\n     */\n    cancelAllRequests(): Client {\n        for (let k in this.cancelControllers) {\n            this.cancelControllers[k].abort();\n        }\n\n        this.cancelControllers = {};\n\n        return this;\n    }\n\n    /**\n     * Sends an api http request.\n     */\n    async send<T = any>(path: string, reqOptions: SendOptions): Promise<T> {\n        let options = Object.assign({ method: 'GET' } as SendOptions, reqOptions);\n\n        // JSON serialize the body if needed and set the correct content type\n        // (for FormData body the Content-Type header should be skipped since the boundary is autogenerated)\n        if (!this.isFormData(options.body)) {\n            if (options.body && typeof options.body !== 'string') {\n                options.body = JSON.stringify(options.body);\n            }\n\n            // add the json header (if not already)\n            if (typeof options?.headers?.['Content-Type'] === 'undefined') {\n                options.headers = Object.assign({}, options.headers, {\n                    'Content-Type': 'application/json',\n                });\n            }\n        }\n\n        // add Accept-Language header (if not already)\n        if (typeof options?.headers?.['Accept-Language'] === 'undefined') {\n            options.headers = Object.assign({}, options.headers, {\n                'Accept-Language': this.lang,\n            });\n        }\n\n        // check if Authorization header can be added\n        if (\n            // has stored token\n            this.authStore?.token &&\n            // auth header is not explicitly set\n            (typeof options?.headers?.Authorization === 'undefined')\n        ) {\n            options.headers = Object.assign({}, options.headers, {\n                'Authorization': this.authStore.token,\n            });\n        }\n\n        // handle auto cancelation for duplicated pending request\n        if (this.enableAutoCancellation && options.params?.$autoCancel !== false) {\n            const cancelKey = options.params?.$cancelKey || ((options.method || 'GET') + path);\n\n            // cancel previous pending requests\n            this.cancelRequest(cancelKey);\n\n            const controller = new AbortController();\n            this.cancelControllers[cancelKey] = controller;\n            options.signal = controller.signal;\n        }\n        // remove the special cancellation params from the other valid query params\n        delete options.params?.$autoCancel;\n        delete options.params?.$cancelKey;\n\n        // build url + path\n        let url = this.buildUrl(path);\n\n        // serialize the query parameters\n        if (typeof options.params !== 'undefined') {\n            const query = this.serializeQueryParams(options.params)\n            if (query) {\n                url += (url.includes('?') ? '&' : '?') + query;\n            }\n            delete options.params;\n        }\n\n        if (this.beforeSend) {\n            const result = Object.assign({}, await this.beforeSend(url, options));\n            if (typeof result.url !== \"undefined\" || typeof result.options !== \"undefined\") {\n                url = result.url || url;\n                options = result.options || options;\n            } else if (Object.keys(result).length) {\n                // legacy behavior\n                options = result as SendOptions;\n                console?.warn && console.warn(\"Deprecated format of beforeSend return: please use `return { url, options }`, instead of `return options`.\");\n            }\n        }\n\n        // send the request\n        return fetch(url, options)\n            .then(async (response) => {\n                let data : any = {};\n\n                try {\n                    data = await response.json();\n                } catch (_) {\n                    // all api responses are expected to return json\n                    // with the exception of the realtime event and 204\n                }\n\n                if (this.afterSend) {\n                    data = await this.afterSend(response, data);\n                }\n\n                if (response.status >= 400) {\n                    throw new ClientResponseError({\n                        url:      response.url,\n                        status:   response.status,\n                        data:     data,\n                    });\n                }\n\n                return data as T;\n            }).catch((err) => {\n                // wrap to normalize all errors\n                throw new ClientResponseError(err);\n            });\n    }\n\n    /**\n     * Legacy alias of `pb.files.getUrl()`.\n     */\n    getFileUrl(\n        record: Pick<Record, \"id\" | \"collectionId\" | \"collectionName\">,\n        filename: string,\n        queryParams: FileQueryParams = {}\n    ): string {\n        return this.files.getUrl(record, filename, queryParams);\n    }\n\n    /**\n     * Builds a full client url by safely concatenating the provided path.\n     */\n    buildUrl(path: string): string {\n        let url = this.baseUrl;\n\n        // construct an absolute base url if in a browser environment\n        if (\n            typeof window !== 'undefined' &&\n            !!window.location &&\n            !url.startsWith('https://') &&\n            !url.startsWith('http://')\n        ) {\n            url = window.location.origin?.endsWith('/') ?\n                window.location.origin.substring(0, window.location.origin.length - 1) :\n                (window.location.origin || '');\n\n            if (!this.baseUrl.startsWith('/')) {\n                url += window.location.pathname || '/';\n                url += url.endsWith('/') ? '' : '/';\n            }\n\n            url += this.baseUrl;\n        }\n\n        // concatenate the path\n        if (path) {\n            url += url.endsWith('/') ? '' : '/'; // append trailing slash if missing\n            url += path.startsWith('/') ? path.substring(1) : path;\n        }\n\n        return url;\n    }\n\n    /**\n     * Loosely checks if the specified body is a FormData instance.\n     */\n    private isFormData(body: any): boolean {\n        return body && (\n            // we are checking the constructor name because FormData\n            // is not available natively in some environments and the\n            // polyfill(s) may not be globally accessible\n            body.constructor.name === 'FormData' ||\n            // fallback to global FormData instance check\n            // note: this is needed because the constructor.name could be different in case of\n            //       custom global FormData implementation, eg. React Native on Android/iOS\n            (typeof FormData !== \"undefined\" && body instanceof FormData)\n        )\n    }\n\n    /**\n     * Serializes the provided query parameters into a query string.\n     */\n    private serializeQueryParams(params: {[key: string]: any}): string {\n        const result: Array<string> = [];\n        for (const key in params) {\n            if (params[key] === null) {\n                // skip null query params\n                continue;\n            }\n\n            const value = params[key];\n            const encodedKey = encodeURIComponent(key);\n\n            if (Array.isArray(value)) {\n                // \"repeat\" array params\n                for (const v of value) {\n                    result.push(encodedKey + \"=\" + encodeURIComponent(v));\n                }\n            } else if (value instanceof Date) {\n                result.push(encodedKey + \"=\" + encodeURIComponent(value.toISOString()));\n            } else if (typeof value !== null && typeof value === 'object') {\n                result.push(encodedKey + \"=\" + encodeURIComponent(JSON.stringify(value)));\n            } else {\n                result.push(encodedKey + \"=\" + encodeURIComponent(value));\n            }\n        }\n\n        return result.join('&');\n    }\n}\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","TypeError","String","__","this","constructor","create","__assign","assign","t","s","i","n","arguments","length","apply","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","adopt","then","__generator","body","f","y","g","_","label","sent","trys","ops","verb","throw","return","Symbol","iterator","v","op","pop","push","atobPolyfill","ClientResponseError","_super","errData","_this","url","status","response","isAbort","originalError","data","DOMException","name","message","_a","_d","_c","_b","cause","includes","defineProperty","get","toJSON","Error","fieldContentRegExp","cookieSerialize","val","options","opt","encode","defaultEncode","test","maxAge","isNaN","isFinite","Math","floor","domain","path","expires","isDate","toString","Date","valueOf","toUTCString","httpOnly","secure","priority","toLowerCase","sameSite","defaultDecode","indexOf","decodeURIComponent","encodeURIComponent","getTokenPayload","token","encodedPayload","split","map","c","charCodeAt","slice","join","JSON","parse","isTokenExpired","expirationThreshold","payload","keys","exp","now","atob","input","str","replace","bs","buffer","bc","idx","output","charAt","fromCharCode","BaseModel","$load","load","_i","entries","key","id","created","updated","clone","$clone","structuredClone","stringify","export","$export","Record","collectionId","collectionName","_loadExpand","expand","isArray","Admin","avatar","email","defaultCookieKey","BaseAuthStore","baseToken","baseModel","_onChangeCallbacks","save","model","triggerChange","clear","loadFromCookie","cookie","rawData","cookieParse","decode","index","eqIdx","endIdx","lastIndexOf","trim","undefined","exportToCookie","defaultOptions","resultLength","Blob","size","username","verified","onChange","callback","fireImmediately","splice","LocalAuthStore","storageKey","storageFallback","_storageGet","_storageSet","_storageRemove","window","localStorage","rawValue","getItem","normalizedVal","setItem","removeItem","BaseService","client","SettingsService","getAll","queryParams","send","method","params","responseData","update","bodyParams","testS3","filesystem","testEmail","toEmail","emailTemplate","template","generateAppleClientSecret","clientId","teamId","keyId","privateKey","duration","ListResult","page","perPage","totalItems","totalPages","items","CrudService","getFullList","batchOrqueryParams","_getFullList","baseCrudPath","batch","getList","_getList","getFirstListItem","filter","_getFirstListItem","getOne","_getOne","_create","_update","delete","_delete","BaseCrudService","basePath","batchSize","request","list","castedList","concat","item","$cancelKey","code","AdminService","authStore","success","authResponse","admin","authWithPassword","password","identity","bind","authRefresh","requestPasswordReset","confirmPasswordReset","passwordResetToken","passwordConfirm","ExternalAuth","recordId","provider","providerId","RecordService","collectionIdOrName","baseCollectionPath","subscribeOne","console","warn","realtime","subscribe","topicOrCallback","topic","unsubscribe","unsubscribeByPrefix","batchOrQueryParams","record","listAuthMethods","usernamePassword","emailPassword","authProviders","usernameOrEmail","authWithOAuth2Code","codeVerifier","redirectUrl","createData","authWithOAuth2","args","config","authMethods","find","buildUrl","oldState","unsubscribe_1","state","query","authData","err_2","replacements","scopes","_replaceQueryParams","authUrl","urlCallback","_defaultUrlCallback","err_1","requestVerification","confirmVerification","verificationToken","requestEmailChange","newEmail","confirmEmailChange","emailChangeToken","listExternalAuths","responseData_1","unlinkExternalAuth","urlPath","substring","parsedParams","rawParams_1","param","pair","open","width","height","windowWidth","innerWidth","windowHeight","innerHeight","left","top","SchemaField","type","system","required","Collection","indexes","listRule","viewRule","createRule","updateRule","deleteRule","schema","field","$isBase","$isAuth","$isView","CollectionService","import","collections","deleteMissing","LogRequest","remoteIp","ip","auth","userIp","referer","userAgent","meta","LogService","getRequestsList","getRequest","getRequestsStats","RealtimeService","eventSource","subscriptions","lastSentTopics","maxConnectTimeout","reconnectAttempts","maxReconnectAttempts","Infinity","predefinedReconnectIntervals","pendingConnects","listener","msgEvent","isConnected","connect","submitSubscriptions","addEventListener","unsubscribeByTopicAndListener","hasSubscriptionListeners","removeEventListener","disconnect","topicPrefix","hasAtleastOneTopic","startsWith","exist","topicToCheck","addAllSubscriptionListeners","getNonEmptySubscriptionTopics","getSubscriptionsCancelKey","catch","err","removeAllSubscriptionListeners","initConnect","clearTimeout","connectTimeoutId","setTimeout","connectErrorHandler","EventSource","onerror","lastEventId","retries","hasUnsentSubscriptions","reconnectTimeoutId","latestTopics","latestTopics_1","timeout","fromReconnect","cancelRequest","close","HealthService","check","FileService","getUrl","filename","parts","URLSearchParams","getToken","BackupService","basename","restore","getDownloadUrl","Client","baseUrl","lang","cancelControllers","recordServices","enableAutoCancellation","admins","files","logs","settings","health","backups","collection","idOrName","autoCancellation","enable","cancelKey","abort","cancelAllRequests","k","reqOptions","isFormData","headers","Authorization","_e","$autoCancel","_f","controller","AbortController","signal","_g","_h","serializeQueryParams","beforeSend","_k","_j","_l","_m","fetch","json","afterSend","getFileUrl","location","origin","endsWith","pathname","FormData","encodedKey","value_1","toISOString"],"mappings":"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"}