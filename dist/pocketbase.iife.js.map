{"version":3,"file":"pocketbase.iife.js","sources":["../src/ClientResponseError.ts","../src/stores/utils/cookie.ts","../src/stores/utils/jwt.ts","../src/stores/BaseAuthStore.ts","../src/stores/LocalAuthStore.ts","../src/services/utils/BaseService.ts","../src/services/SettingsService.ts","../src/services/utils/CrudService.ts","../src/services/utils/legacy.ts","../src/services/utils/refresh.ts","../src/services/AdminService.ts","../src/services/utils/options.ts","../src/services/RealtimeService.ts","../src/services/RecordService.ts","../src/services/CollectionService.ts","../src/services/LogService.ts","../src/services/HealthService.ts","../src/services/FileService.ts","../src/services/BackupService.ts","../src/stores/AsyncAuthStore.ts","../src/Client.ts"],"sourcesContent":["/**\r\n * ClientResponseError is a custom Error class that is intended to wrap\r\n * and normalize any error thrown by `Client.send()`.\r\n */\r\nexport class ClientResponseError extends Error {\r\n    url: string = \"\";\r\n    status: number = 0;\r\n    response: { [key: string]: any } = {};\r\n    isAbort: boolean = false;\r\n    originalError: any = null;\r\n\r\n    constructor(errData?: any) {\r\n        super(\"ClientResponseError\");\r\n\r\n        // Set the prototype explicitly.\r\n        // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, ClientResponseError.prototype);\r\n\r\n        if (errData !== null && typeof errData === \"object\") {\r\n            this.url = typeof errData.url === \"string\" ? errData.url : \"\";\r\n            this.status = typeof errData.status === \"number\" ? errData.status : 0;\r\n            this.isAbort = !!errData.isAbort;\r\n            this.originalError = errData.originalError;\r\n\r\n            if (errData.response !== null && typeof errData.response === \"object\") {\r\n                this.response = errData.response;\r\n            } else if (errData.data !== null && typeof errData.data === \"object\") {\r\n                this.response = errData.data;\r\n            } else {\r\n                this.response = {};\r\n            }\r\n        }\r\n\r\n        if (!this.originalError && !(errData instanceof ClientResponseError)) {\r\n            this.originalError = errData;\r\n        }\r\n\r\n        if (typeof DOMException !== \"undefined\" && errData instanceof DOMException) {\r\n            this.isAbort = true;\r\n        }\r\n\r\n        this.name = \"ClientResponseError \" + this.status;\r\n        this.message = this.response?.message;\r\n        if (!this.message) {\r\n            if (this.isAbort) {\r\n                this.message =\r\n                    \"The request was autocancelled. You can find more info in https://github.com/pocketbase/js-sdk#auto-cancellation.\";\r\n            } else if (this.originalError?.cause?.message?.includes(\"ECONNREFUSED ::1\")) {\r\n                this.message =\r\n                    \"Failed to connect to the PocketBase server. Try changing the SDK URL from localhost to 127.0.0.1 (https://github.com/pocketbase/js-sdk/issues/21).\";\r\n            } else {\r\n                this.message = \"Something went wrong while processing your request.\";\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Alias for `this.response` to preserve the backward compatibility.\r\n     */\r\n    get data() {\r\n        return this.response;\r\n    }\r\n\r\n    /**\r\n     * Make a POJO's copy of the current error class instance.\r\n     * @see https://github.com/vuex-orm/vuex-orm/issues/255\r\n     */\r\n    toJSON() {\r\n        return { ...this };\r\n    }\r\n}\r\n","/**\r\n * -------------------------------------------------------------------\r\n * Simple cookie parse and serialize utilities mostly based on the\r\n * node module https://github.com/jshttp/cookie.\r\n * -------------------------------------------------------------------\r\n */\r\n\r\n/**\r\n * RegExp to match field-content in RFC 7230 sec 3.2\r\n *\r\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\r\n * field-vchar   = VCHAR / obs-text\r\n * obs-text      = %x80-FF\r\n */\r\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\r\n\r\nexport interface ParseOptions {\r\n    decode?: (val: string) => string;\r\n}\r\n\r\n/**\r\n * Parses the given cookie header string into an object\r\n * The object has the various cookies as keys(names) => values\r\n */\r\nexport function cookieParse(str: string, options?: ParseOptions): { [key: string]: any } {\r\n    const result: { [key: string]: any } = {};\r\n\r\n    if (typeof str !== \"string\") {\r\n        return result;\r\n    }\r\n\r\n    const opt = Object.assign({}, options || {});\r\n    const decode = opt.decode || defaultDecode;\r\n\r\n    let index = 0;\r\n    while (index < str.length) {\r\n        const eqIdx = str.indexOf(\"=\", index);\r\n\r\n        // no more cookie pairs\r\n        if (eqIdx === -1) {\r\n            break;\r\n        }\r\n\r\n        let endIdx = str.indexOf(\";\", index);\r\n\r\n        if (endIdx === -1) {\r\n            endIdx = str.length;\r\n        } else if (endIdx < eqIdx) {\r\n            // backtrack on prior semicolon\r\n            index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\r\n            continue;\r\n        }\r\n\r\n        const key = str.slice(index, eqIdx).trim();\r\n\r\n        // only assign once\r\n        if (undefined === result[key]) {\r\n            let val = str.slice(eqIdx + 1, endIdx).trim();\r\n\r\n            // quoted values\r\n            if (val.charCodeAt(0) === 0x22) {\r\n                val = val.slice(1, -1);\r\n            }\r\n\r\n            try {\r\n                result[key] = decode(val);\r\n            } catch (_) {\r\n                result[key] = val; // no decoding\r\n            }\r\n        }\r\n\r\n        index = endIdx + 1;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nexport interface SerializeOptions {\r\n    encode?: (val: string | number | boolean) => string;\r\n    maxAge?: number;\r\n    domain?: string;\r\n    path?: string;\r\n    expires?: Date;\r\n    httpOnly?: boolean;\r\n    secure?: boolean;\r\n    priority?: string;\r\n    sameSite?: boolean | string;\r\n}\r\n\r\n/**\r\n * Serialize data into a cookie header.\r\n *\r\n * Serialize the a name value pair into a cookie string suitable for\r\n * http headers. An optional options object specified cookie parameters.\r\n *\r\n * ```js\r\n * cookieSerialize('foo', 'bar', { httpOnly: true }) // \"foo=bar; httpOnly\"\r\n * ```\r\n */\r\nexport function cookieSerialize(\r\n    name: string,\r\n    val: string,\r\n    options?: SerializeOptions,\r\n): string {\r\n    const opt = Object.assign({}, options || {});\r\n    const encode = opt.encode || defaultEncode;\r\n\r\n    if (!fieldContentRegExp.test(name)) {\r\n        throw new TypeError(\"argument name is invalid\");\r\n    }\r\n\r\n    const value = encode(val);\r\n\r\n    if (value && !fieldContentRegExp.test(value)) {\r\n        throw new TypeError(\"argument val is invalid\");\r\n    }\r\n\r\n    let result = name + \"=\" + value;\r\n\r\n    if (opt.maxAge != null) {\r\n        const maxAge = opt.maxAge - 0;\r\n\r\n        if (isNaN(maxAge) || !isFinite(maxAge)) {\r\n            throw new TypeError(\"option maxAge is invalid\");\r\n        }\r\n\r\n        result += \"; Max-Age=\" + Math.floor(maxAge);\r\n    }\r\n\r\n    if (opt.domain) {\r\n        if (!fieldContentRegExp.test(opt.domain)) {\r\n            throw new TypeError(\"option domain is invalid\");\r\n        }\r\n\r\n        result += \"; Domain=\" + opt.domain;\r\n    }\r\n\r\n    if (opt.path) {\r\n        if (!fieldContentRegExp.test(opt.path)) {\r\n            throw new TypeError(\"option path is invalid\");\r\n        }\r\n\r\n        result += \"; Path=\" + opt.path;\r\n    }\r\n\r\n    if (opt.expires) {\r\n        if (!isDate(opt.expires) || isNaN(opt.expires.valueOf())) {\r\n            throw new TypeError(\"option expires is invalid\");\r\n        }\r\n\r\n        result += \"; Expires=\" + opt.expires.toUTCString();\r\n    }\r\n\r\n    if (opt.httpOnly) {\r\n        result += \"; HttpOnly\";\r\n    }\r\n\r\n    if (opt.secure) {\r\n        result += \"; Secure\";\r\n    }\r\n\r\n    if (opt.priority) {\r\n        const priority =\r\n            typeof opt.priority === \"string\" ? opt.priority.toLowerCase() : opt.priority;\r\n\r\n        switch (priority) {\r\n            case \"low\":\r\n                result += \"; Priority=Low\";\r\n                break;\r\n            case \"medium\":\r\n                result += \"; Priority=Medium\";\r\n                break;\r\n            case \"high\":\r\n                result += \"; Priority=High\";\r\n                break;\r\n            default:\r\n                throw new TypeError(\"option priority is invalid\");\r\n        }\r\n    }\r\n\r\n    if (opt.sameSite) {\r\n        const sameSite =\r\n            typeof opt.sameSite === \"string\" ? opt.sameSite.toLowerCase() : opt.sameSite;\r\n\r\n        switch (sameSite) {\r\n            case true:\r\n                result += \"; SameSite=Strict\";\r\n                break;\r\n            case \"lax\":\r\n                result += \"; SameSite=Lax\";\r\n                break;\r\n            case \"strict\":\r\n                result += \"; SameSite=Strict\";\r\n                break;\r\n            case \"none\":\r\n                result += \"; SameSite=None\";\r\n                break;\r\n            default:\r\n                throw new TypeError(\"option sameSite is invalid\");\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\n/**\r\n * Default URL-decode string value function.\r\n * Optimized to skip native call when no `%`.\r\n */\r\nfunction defaultDecode(val: string): string {\r\n    return val.indexOf(\"%\") !== -1 ? decodeURIComponent(val) : val;\r\n}\r\n\r\n/**\r\n * Default URL-encode value function.\r\n */\r\nfunction defaultEncode(val: string | number | boolean): string {\r\n    return encodeURIComponent(val);\r\n}\r\n\r\n/**\r\n * Determines if value is a Date.\r\n */\r\nfunction isDate(val: any): boolean {\r\n    return Object.prototype.toString.call(val) === \"[object Date]\" || val instanceof Date;\r\n}\r\n","// @todo remove after https://github.com/reactwg/react-native-releases/issues/287\r\nconst isReactNative = (\r\n    (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') ||\r\n    (typeof global !== 'undefined' && (global as any).HermesInternal)\r\n);\r\n\r\nlet atobPolyfill: Function;\r\nif (typeof atob === \"function\" && !isReactNative) {\r\n    atobPolyfill = atob;\r\n} else {\r\n    /**\r\n     * The code was extracted from:\r\n     * https://github.com/davidchambers/Base64.js\r\n     */\r\n    atobPolyfill = (input: any) => {\r\n        const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\r\n\r\n        let str = String(input).replace(/=+$/, \"\");\r\n        if (str.length % 4 == 1) {\r\n            throw new Error(\r\n                \"'atob' failed: The string to be decoded is not correctly encoded.\",\r\n            );\r\n        }\r\n\r\n        for (\r\n            // initialize result and counters\r\n            var bc = 0, bs, buffer, idx = 0, output = \"\";\r\n            // get next character\r\n            (buffer = str.charAt(idx++));\r\n            // character found in table? initialize bit storage and add its ascii value;\r\n            ~buffer &&\r\n                ((bs = bc % 4 ? (bs as any) * 64 + buffer : buffer),\r\n                    // and if not first of each 4 characters,\r\n                    // convert the first 8 bits to one ascii character\r\n                    bc++ % 4)\r\n                ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))\r\n                : 0\r\n        ) {\r\n            // try to find character in table (0-63, not found => -1)\r\n            buffer = chars.indexOf(buffer);\r\n        }\r\n\r\n        return output;\r\n    };\r\n}\r\n\r\n/**\r\n * Returns JWT token's payload data.\r\n */\r\nexport function getTokenPayload(token: string): { [key: string]: any } {\r\n    if (token) {\r\n        try {\r\n            const encodedPayload = decodeURIComponent(\r\n                atobPolyfill(token.split(\".\")[1])\r\n                    .split(\"\")\r\n                    .map(function (c: string) {\r\n                        return \"%\" + (\"00\" + c.charCodeAt(0).toString(16)).slice(-2);\r\n                    })\r\n                    .join(\"\"),\r\n            );\r\n\r\n            return JSON.parse(encodedPayload) || {};\r\n        } catch (e) {}\r\n    }\r\n\r\n    return {};\r\n}\r\n\r\n/**\r\n * Checks whether a JWT token is expired or not.\r\n * Tokens without `exp` payload key are considered valid.\r\n * Tokens with empty payload (eg. invalid token strings) are considered expired.\r\n *\r\n * @param token The token to check.\r\n * @param [expirationThreshold] Time in seconds that will be subtracted from the token `exp` property.\r\n */\r\nexport function isTokenExpired(token: string, expirationThreshold = 0): boolean {\r\n    let payload = getTokenPayload(token);\r\n\r\n    if (\r\n        Object.keys(payload).length > 0 &&\r\n        (!payload.exp || payload.exp - expirationThreshold > Date.now() / 1000)\r\n    ) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n","import { cookieParse, cookieSerialize, SerializeOptions } from \"@/stores/utils/cookie\";\r\nimport { isTokenExpired, getTokenPayload } from \"@/stores/utils/jwt\";\r\n\r\nexport type AuthModel = { [key: string]: any } | null;\r\n\r\nexport type OnStoreChangeFunc = (token: string, model: AuthModel) => void;\r\n\r\nconst defaultCookieKey = \"pb_auth\";\r\n\r\n/**\r\n * Base AuthStore class that is intended to be extended by all other\r\n * PocketBase AuthStore implementations.\r\n */\r\nexport abstract class BaseAuthStore {\r\n    protected baseToken: string = \"\";\r\n    protected baseModel: AuthModel = null;\r\n\r\n    private _onChangeCallbacks: Array<OnStoreChangeFunc> = [];\r\n\r\n    /**\r\n     * Retrieves the stored token (if any).\r\n     */\r\n    get token(): string {\r\n        return this.baseToken;\r\n    }\r\n\r\n    /**\r\n     * Retrieves the stored model data (if any).\r\n     */\r\n    get model(): AuthModel {\r\n        return this.baseModel;\r\n    }\r\n\r\n    /**\r\n     * Loosely checks if the store has valid token (aka. existing and unexpired exp claim).\r\n     */\r\n    get isValid(): boolean {\r\n        return !isTokenExpired(this.token);\r\n    }\r\n\r\n    /**\r\n     * Checks whether the current store state is for admin authentication.\r\n     */\r\n    get isAdmin(): boolean {\r\n        return getTokenPayload(this.token).type === \"admin\";\r\n    }\r\n\r\n    /**\r\n     * Checks whether the current store state is for auth record authentication.\r\n     */\r\n    get isAuthRecord(): boolean {\r\n        return getTokenPayload(this.token).type === \"authRecord\";\r\n    }\r\n\r\n    /**\r\n     * Saves the provided new token and model data in the auth store.\r\n     */\r\n    save(token: string, model?: AuthModel): void {\r\n        this.baseToken = token || \"\";\r\n        this.baseModel = model || null;\r\n\r\n        this.triggerChange();\r\n    }\r\n\r\n    /**\r\n     * Removes the stored token and model data form the auth store.\r\n     */\r\n    clear(): void {\r\n        this.baseToken = \"\";\r\n        this.baseModel = null;\r\n        this.triggerChange();\r\n    }\r\n\r\n    /**\r\n     * Parses the provided cookie string and updates the store state\r\n     * with the cookie's token and model data.\r\n     *\r\n     * NB! This function doesn't validate the token or its data.\r\n     * Usually this isn't a concern if you are interacting only with the\r\n     * PocketBase API because it has the proper server-side security checks in place,\r\n     * but if you are using the store `isValid` state for permission controls\r\n     * in a node server (eg. SSR), then it is recommended to call `authRefresh()`\r\n     * after loading the cookie to ensure an up-to-date token and model state.\r\n     * For example:\r\n     *\r\n     * ```js\r\n     * pb.authStore.loadFromCookie(\"cookie string...\");\r\n     *\r\n     * try {\r\n     *     // get an up-to-date auth store state by veryfing and refreshing the loaded auth model (if any)\r\n     *     pb.authStore.isValid && await pb.collection('users').authRefresh();\r\n     * } catch (_) {\r\n     *     // clear the auth store on failed refresh\r\n     *     pb.authStore.clear();\r\n     * }\r\n     * ```\r\n     */\r\n    loadFromCookie(cookie: string, key = defaultCookieKey): void {\r\n        const rawData = cookieParse(cookie || \"\")[key] || \"\";\r\n\r\n        let data: { [key: string]: any } = {};\r\n        try {\r\n            data = JSON.parse(rawData);\r\n            // normalize\r\n            if (typeof data === null || typeof data !== \"object\" || Array.isArray(data)) {\r\n                data = {};\r\n            }\r\n        } catch (_) {}\r\n\r\n        this.save(data.token || \"\", data.model || null);\r\n    }\r\n\r\n    /**\r\n     * Exports the current store state as cookie string.\r\n     *\r\n     * By default the following optional attributes are added:\r\n     * - Secure\r\n     * - HttpOnly\r\n     * - SameSite=Strict\r\n     * - Path=/\r\n     * - Expires={the token expiration date}\r\n     *\r\n     * NB! If the generated cookie exceeds 4096 bytes, this method will\r\n     * strip the model data to the bare minimum to try to fit within the\r\n     * recommended size in https://www.rfc-editor.org/rfc/rfc6265#section-6.1.\r\n     */\r\n    exportToCookie(options?: SerializeOptions, key = defaultCookieKey): string {\r\n        const defaultOptions: SerializeOptions = {\r\n            secure: true,\r\n            sameSite: true,\r\n            httpOnly: true,\r\n            path: \"/\",\r\n        };\r\n\r\n        // extract the token expiration date\r\n        const payload = getTokenPayload(this.token);\r\n        if (payload?.exp) {\r\n            defaultOptions.expires = new Date(payload.exp * 1000);\r\n        } else {\r\n            defaultOptions.expires = new Date(\"1970-01-01\");\r\n        }\r\n\r\n        // merge with the user defined options\r\n        options = Object.assign({}, defaultOptions, options);\r\n\r\n        const rawData = {\r\n            token: this.token,\r\n            model: this.model ? JSON.parse(JSON.stringify(this.model)) : null,\r\n        };\r\n\r\n        let result = cookieSerialize(key, JSON.stringify(rawData), options);\r\n\r\n        const resultLength =\r\n            typeof Blob !== \"undefined\" ? new Blob([result]).size : result.length;\r\n\r\n        // strip down the model data to the bare minimum\r\n        if (rawData.model && resultLength > 4096) {\r\n            rawData.model = { id: rawData?.model?.id, email: rawData?.model?.email };\r\n            const extraProps = [\"collectionId\", \"username\", \"verified\"];\r\n            for (const prop in this.model) {\r\n                if (extraProps.includes(prop)) {\r\n                    rawData.model[prop] = this.model[prop];\r\n                }\r\n            }\r\n            result = cookieSerialize(key, JSON.stringify(rawData), options);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Register a callback function that will be called on store change.\r\n     *\r\n     * You can set the `fireImmediately` argument to true in order to invoke\r\n     * the provided callback right after registration.\r\n     *\r\n     * Returns a removal function that you could call to \"unsubscribe\" from the changes.\r\n     */\r\n    onChange(callback: OnStoreChangeFunc, fireImmediately = false): () => void {\r\n        this._onChangeCallbacks.push(callback);\r\n\r\n        if (fireImmediately) {\r\n            callback(this.token, this.model);\r\n        }\r\n\r\n        return () => {\r\n            for (let i = this._onChangeCallbacks.length - 1; i >= 0; i--) {\r\n                if (this._onChangeCallbacks[i] == callback) {\r\n                    delete this._onChangeCallbacks[i]; // removes the function reference\r\n                    this._onChangeCallbacks.splice(i, 1); // reindex the array\r\n                    return;\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    protected triggerChange(): void {\r\n        for (const callback of this._onChangeCallbacks) {\r\n            callback && callback(this.token, this.model);\r\n        }\r\n    }\r\n}\r\n","import { BaseAuthStore, AuthModel } from \"@/stores/BaseAuthStore\";\r\n\r\n/**\r\n * The default token store for browsers with auto fallback\r\n * to runtime/memory if local storage is undefined (eg. in node env).\r\n */\r\nexport class LocalAuthStore extends BaseAuthStore {\r\n    private storageFallback: { [key: string]: any } = {};\r\n    private storageKey: string;\r\n\r\n    constructor(storageKey = \"pocketbase_auth\") {\r\n        super();\r\n\r\n        this.storageKey = storageKey;\r\n\r\n        this._bindStorageEvent();\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    get token(): string {\r\n        const data = this._storageGet(this.storageKey) || {};\r\n\r\n        return data.token || \"\";\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    get model(): AuthModel {\r\n        const data = this._storageGet(this.storageKey) || {};\r\n\r\n        return data.model || null;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    save(token: string, model?: AuthModel) {\r\n        this._storageSet(this.storageKey, {\r\n            token: token,\r\n            model: model,\r\n        });\r\n\r\n        super.save(token, model);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    clear() {\r\n        this._storageRemove(this.storageKey);\r\n\r\n        super.clear();\r\n    }\r\n\r\n    // ---------------------------------------------------------------\r\n    // Internal helpers:\r\n    // ---------------------------------------------------------------\r\n\r\n    /**\r\n     * Retrieves `key` from the browser's local storage\r\n     * (or runtime/memory if local storage is undefined).\r\n     */\r\n    private _storageGet(key: string): any {\r\n        if (typeof window !== \"undefined\" && window?.localStorage) {\r\n            const rawValue = window.localStorage.getItem(key) || \"\";\r\n            try {\r\n                return JSON.parse(rawValue);\r\n            } catch (e) {\r\n                // not a json\r\n                return rawValue;\r\n            }\r\n        }\r\n\r\n        // fallback\r\n        return this.storageFallback[key];\r\n    }\r\n\r\n    /**\r\n     * Stores a new data in the browser's local storage\r\n     * (or runtime/memory if local storage is undefined).\r\n     */\r\n    private _storageSet(key: string, value: any) {\r\n        if (typeof window !== \"undefined\" && window?.localStorage) {\r\n            // store in local storage\r\n            let normalizedVal = value;\r\n            if (typeof value !== \"string\") {\r\n                normalizedVal = JSON.stringify(value);\r\n            }\r\n            window.localStorage.setItem(key, normalizedVal);\r\n        } else {\r\n            // store in fallback\r\n            this.storageFallback[key] = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes `key` from the browser's local storage and the runtime/memory.\r\n     */\r\n    private _storageRemove(key: string) {\r\n        // delete from local storage\r\n        if (typeof window !== \"undefined\" && window?.localStorage) {\r\n            window.localStorage?.removeItem(key);\r\n        }\r\n\r\n        // delete from fallback\r\n        delete this.storageFallback[key];\r\n    }\r\n\r\n    /**\r\n     * Updates the current store state on localStorage change.\r\n     */\r\n    private _bindStorageEvent() {\r\n        if (\r\n            typeof window === \"undefined\" ||\r\n            !window?.localStorage ||\r\n            !window.addEventListener\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        window.addEventListener(\"storage\", (e) => {\r\n            if (e.key != this.storageKey) {\r\n                return;\r\n            }\r\n\r\n            const data = this._storageGet(this.storageKey) || {};\r\n\r\n            super.save(data.token || \"\", data.model || null);\r\n        });\r\n    }\r\n}\r\n","import Client from \"@/Client\";\r\n\r\n/**\r\n * BaseService class that should be inherited from all API services.\r\n */\r\nexport abstract class BaseService {\r\n    readonly client: Client;\r\n\r\n    constructor(client: Client) {\r\n        this.client = client;\r\n    }\r\n}\r\n","import { BaseService } from \"@/services/utils/BaseService\";\r\nimport { CommonOptions } from \"@/services/utils/options\";\r\n\r\ninterface appleClientSecret {\r\n    secret: string;\r\n}\r\n\r\nexport class SettingsService extends BaseService {\r\n    /**\r\n     * Fetch all available app settings.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async getAll(options?: CommonOptions): Promise<{ [key: string]: any }> {\r\n        options = Object.assign(\r\n            {\r\n                method: \"GET\",\r\n            },\r\n            options,\r\n        );\r\n\r\n        return this.client.send(\"/api/settings\", options);\r\n    }\r\n\r\n    /**\r\n     * Bulk updates app settings.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async update(\r\n        bodyParams?: { [key: string]: any } | FormData,\r\n        options?: CommonOptions,\r\n    ): Promise<{ [key: string]: any }> {\r\n        options = Object.assign(\r\n            {\r\n                method: \"PATCH\",\r\n                body: bodyParams,\r\n            },\r\n            options,\r\n        );\r\n\r\n        return this.client.send(\"/api/settings\", options);\r\n    }\r\n\r\n    /**\r\n     * Performs a S3 filesystem connection test.\r\n     *\r\n     * The currently supported `filesystem` are \"storage\" and \"backups\".\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async testS3(\r\n        filesystem: string = \"storage\",\r\n        options?: CommonOptions,\r\n    ): Promise<boolean> {\r\n        options = Object.assign(\r\n            {\r\n                method: \"POST\",\r\n                body: {\r\n                    filesystem: filesystem,\r\n                },\r\n            },\r\n            options,\r\n        );\r\n\r\n        return this.client.send(\"/api/settings/test/s3\", options).then(() => true);\r\n    }\r\n\r\n    /**\r\n     * Sends a test email.\r\n     *\r\n     * The possible `emailTemplate` values are:\r\n     * - verification\r\n     * - password-reset\r\n     * - email-change\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async testEmail(\r\n        toEmail: string,\r\n        emailTemplate: string,\r\n        options?: CommonOptions,\r\n    ): Promise<boolean> {\r\n        options = Object.assign(\r\n            {\r\n                method: \"POST\",\r\n                body: {\r\n                    email: toEmail,\r\n                    template: emailTemplate,\r\n                },\r\n            },\r\n            options,\r\n        );\r\n\r\n        return this.client.send(\"/api/settings/test/email\", options).then(() => true);\r\n    }\r\n\r\n    /**\r\n     * Generates a new Apple OAuth2 client secret.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async generateAppleClientSecret(\r\n        clientId: string,\r\n        teamId: string,\r\n        keyId: string,\r\n        privateKey: string,\r\n        duration: number,\r\n        options?: CommonOptions,\r\n    ): Promise<appleClientSecret> {\r\n        options = Object.assign(\r\n            {\r\n                method: \"POST\",\r\n                body: {\r\n                    clientId,\r\n                    teamId,\r\n                    keyId,\r\n                    privateKey,\r\n                    duration,\r\n                },\r\n            },\r\n            options,\r\n        );\r\n\r\n        return this.client.send(\"/api/settings/apple/generate-client-secret\", options);\r\n    }\r\n}\r\n","import { BaseService } from \"@/services/utils/BaseService\";\r\nimport { ClientResponseError } from \"@/ClientResponseError\";\r\nimport { ListResult } from \"@/services/utils/dtos\";\r\nimport { CommonOptions, ListOptions, FullListOptions } from \"@/services/utils/options\";\r\n\r\nexport abstract class CrudService<M> extends BaseService {\r\n    /**\r\n     * Base path for the crud actions (without trailing slash, eg. '/admins').\r\n     */\r\n    abstract get baseCrudPath(): string;\r\n\r\n    /**\r\n     * Response data decoder.\r\n     */\r\n    decode<T = M>(data: { [key: string]: any }): T {\r\n        return data as T;\r\n    }\r\n\r\n    /**\r\n     * Returns a promise with all list items batch fetched at once\r\n     * (by default 500 items per request; to change it set the `batch` query param).\r\n     *\r\n     * You can use the generic T to supply a wrapper type of the crud model.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async getFullList<T = M>(options?: FullListOptions): Promise<Array<T>>;\r\n\r\n    /**\r\n     * Legacy version of getFullList with explicitly specified batch size.\r\n     */\r\n    async getFullList<T = M>(batch?: number, options?: ListOptions): Promise<Array<T>>;\r\n\r\n    async getFullList<T = M>(\r\n        batchOrqueryParams?: number | FullListOptions,\r\n        options?: ListOptions,\r\n    ): Promise<Array<T>> {\r\n        if (typeof batchOrqueryParams == \"number\") {\r\n            return this._getFullList<T>(batchOrqueryParams, options);\r\n        }\r\n\r\n        options = Object.assign({}, batchOrqueryParams, options);\r\n\r\n        let batch = 500;\r\n        if (options.batch) {\r\n            batch = options.batch;\r\n            delete options.batch;\r\n        }\r\n\r\n        return this._getFullList<T>(batch, options);\r\n    }\r\n\r\n    /**\r\n     * Returns paginated items list.\r\n     *\r\n     * You can use the generic T to supply a wrapper type of the crud model.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async getList<T = M>(\r\n        page = 1,\r\n        perPage = 30,\r\n        options?: ListOptions,\r\n    ): Promise<ListResult<T>> {\r\n        options = Object.assign(\r\n            {\r\n                method: \"GET\",\r\n            },\r\n            options,\r\n        );\r\n\r\n        options.query = Object.assign(\r\n            {\r\n                page: page,\r\n                perPage: perPage,\r\n            },\r\n            options.query,\r\n        );\r\n\r\n        return this.client.send(this.baseCrudPath, options).then((responseData: any) => {\r\n            responseData.items =\r\n                responseData.items?.map((item: any) => {\r\n                    return this.decode<T>(item);\r\n                }) || [];\r\n\r\n            return responseData;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns the first found item by the specified filter.\r\n     *\r\n     * Internally it calls `getList(1, 1, { filter, skipTotal })` and\r\n     * returns the first found item.\r\n     *\r\n     * You can use the generic T to supply a wrapper type of the crud model.\r\n     *\r\n     * For consistency with `getOne`, this method will throw a 404\r\n     * ClientResponseError if no item was found.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async getFirstListItem<T = M>(filter: string, options?: CommonOptions): Promise<T> {\r\n        options = Object.assign(\r\n            {\r\n                requestKey: \"one_by_filter_\" + this.baseCrudPath + \"_\" + filter,\r\n            },\r\n            options,\r\n        );\r\n\r\n        options.query = Object.assign(\r\n            {\r\n                filter: filter,\r\n                skipTotal: 1,\r\n            },\r\n            options.query,\r\n        );\r\n\r\n        return this.getList<T>(1, 1, options).then((result) => {\r\n            if (!result?.items?.length) {\r\n                throw new ClientResponseError({\r\n                    status: 404,\r\n                    response: {\r\n                        code: 404,\r\n                        message: \"The requested resource wasn't found.\",\r\n                        data: {},\r\n                    },\r\n                });\r\n            }\r\n\r\n            return result.items[0];\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns single item by its id.\r\n     *\r\n     * You can use the generic T to supply a wrapper type of the crud model.\r\n     *\r\n     * If `id` is empty it will throw a 404 error.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async getOne<T = M>(id: string, options?: CommonOptions): Promise<T> {\r\n        if (!id) {\r\n            throw new ClientResponseError({\r\n                url: this.client.buildUrl(this.baseCrudPath + \"/\"),\r\n                status: 404,\r\n                response: {\r\n                    code: 404,\r\n                    message: \"Missing required record id.\",\r\n                    data: {},\r\n                },\r\n            });\r\n        }\r\n\r\n        options = Object.assign(\r\n            {\r\n                method: \"GET\",\r\n            },\r\n            options,\r\n        );\r\n\r\n        return this.client\r\n            .send(this.baseCrudPath + \"/\" + encodeURIComponent(id), options)\r\n            .then((responseData: any) => this.decode<T>(responseData));\r\n    }\r\n\r\n    /**\r\n     * Creates a new item.\r\n     *\r\n     * You can use the generic T to supply a wrapper type of the crud model.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async create<T = M>(\r\n        bodyParams?: { [key: string]: any } | FormData,\r\n        options?: CommonOptions,\r\n    ): Promise<T> {\r\n        options = Object.assign(\r\n            {\r\n                method: \"POST\",\r\n                body: bodyParams,\r\n            },\r\n            options,\r\n        );\r\n\r\n        return this.client\r\n            .send(this.baseCrudPath, options)\r\n            .then((responseData: any) => this.decode<T>(responseData));\r\n    }\r\n\r\n    /**\r\n     * Updates an existing item by its id.\r\n     *\r\n     * You can use the generic T to supply a wrapper type of the crud model.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async update<T = M>(\r\n        id: string,\r\n        bodyParams?: { [key: string]: any } | FormData,\r\n        options?: CommonOptions,\r\n    ): Promise<T> {\r\n        options = Object.assign(\r\n            {\r\n                method: \"PATCH\",\r\n                body: bodyParams,\r\n            },\r\n            options,\r\n        );\r\n\r\n        return this.client\r\n            .send(this.baseCrudPath + \"/\" + encodeURIComponent(id), options)\r\n            .then((responseData: any) => this.decode<T>(responseData));\r\n    }\r\n\r\n    /**\r\n     * Deletes an existing item by its id.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async delete(id: string, options?: CommonOptions): Promise<boolean> {\r\n        options = Object.assign(\r\n            {\r\n                method: \"DELETE\",\r\n            },\r\n            options,\r\n        );\r\n\r\n        return this.client\r\n            .send(this.baseCrudPath + \"/\" + encodeURIComponent(id), options)\r\n            .then(() => true);\r\n    }\r\n\r\n    /**\r\n     * Returns a promise with all list items batch fetched at once.\r\n     */\r\n    protected _getFullList<T = M>(\r\n        batchSize = 500,\r\n        options?: ListOptions,\r\n    ): Promise<Array<T>> {\r\n        options = options || {};\r\n        options.query = Object.assign(\r\n            {\r\n                skipTotal: 1,\r\n            },\r\n            options.query,\r\n        );\r\n\r\n        let result: Array<T> = [];\r\n\r\n        let request = async (page: number): Promise<Array<any>> => {\r\n            return this.getList(page, batchSize || 500, options).then((list) => {\r\n                const castedList = list as any as ListResult<T>;\r\n                const items = castedList.items;\r\n\r\n                result = result.concat(items);\r\n\r\n                if (items.length == list.perPage) {\r\n                    return request(page + 1);\r\n                }\r\n\r\n                return result;\r\n            });\r\n        };\r\n\r\n        return request(1);\r\n    }\r\n}\r\n","import { SendOptions } from \"@/services/utils/options\";\r\n\r\nexport function normalizeLegacyOptionsArgs(\r\n    legacyWarn: string,\r\n    baseOptions: SendOptions,\r\n    bodyOrOptions?: any,\r\n    query?: any,\r\n): SendOptions {\r\n    const hasBodyOrOptions = typeof bodyOrOptions !== \"undefined\";\r\n    const hasQuery = typeof query !== \"undefined\";\r\n\r\n    if (!hasQuery && !hasBodyOrOptions) {\r\n        return baseOptions;\r\n    }\r\n\r\n    if (hasQuery) {\r\n        console.warn(legacyWarn);\r\n        baseOptions.body = Object.assign({}, baseOptions.body, bodyOrOptions);\r\n        baseOptions.query = Object.assign({}, baseOptions.query, query);\r\n\r\n        return baseOptions;\r\n    }\r\n\r\n    return Object.assign(baseOptions, bodyOrOptions);\r\n}\r\n","import Client from \"@/Client\";\r\nimport { isTokenExpired } from \"@/stores/utils/jwt\";\r\n\r\n// reset previous auto refresh registrations\r\nexport function resetAutoRefresh(client: Client) {\r\n    (client as any)._resetAutoRefresh?.();\r\n}\r\n\r\nexport function registerAutoRefresh(\r\n    client: Client,\r\n    threshold: number,\r\n    refreshFunc: () => Promise<any>,\r\n    reauthenticateFunc: () => Promise<any>,\r\n) {\r\n    resetAutoRefresh(client);\r\n\r\n    const oldBeforeSend = client.beforeSend;\r\n    const oldModel = client.authStore.model;\r\n\r\n    // unset the auto refresh in case the auth store was cleared\r\n    // OR a new model was authenticated\r\n    const unsubStoreChange = client.authStore.onChange((newToken, model) => {\r\n        if (\r\n            !newToken ||\r\n            model?.id != oldModel?.id ||\r\n            // check the collection id in case an admin and auth record share the same id\r\n            ((model?.collectionId || oldModel?.collectionId) &&\r\n                model?.collectionId != oldModel?.collectionId)\r\n        ) {\r\n            resetAutoRefresh(client);\r\n        }\r\n    });\r\n\r\n    // initialize a reset function and attach it dynamically to the client\r\n    (client as any)._resetAutoRefresh = function () {\r\n        unsubStoreChange();\r\n        client.beforeSend = oldBeforeSend;\r\n        delete (client as any)._resetAutoRefresh;\r\n    };\r\n\r\n    client.beforeSend = async (url, sendOptions) => {\r\n        const oldToken = client.authStore.token;\r\n\r\n        if (sendOptions.query?.autoRefresh) {\r\n            return oldBeforeSend ? oldBeforeSend(url, sendOptions) : { url, sendOptions };\r\n        }\r\n\r\n        let isValid = client.authStore.isValid;\r\n        if (\r\n            // is loosely valid\r\n            isValid &&\r\n            // but it is going to expire in the next \"threshold\" seconds\r\n            isTokenExpired(client.authStore.token, threshold)\r\n        ) {\r\n            try {\r\n                await refreshFunc();\r\n            } catch (_) {\r\n                isValid = false;\r\n            }\r\n        }\r\n\r\n        // still invalid -> reauthenticate\r\n        if (!isValid) {\r\n            await reauthenticateFunc();\r\n        }\r\n\r\n        // the request wasn't sent with a custom token\r\n        const headers = sendOptions.headers || {};\r\n        for (let key in headers) {\r\n            if (\r\n                key.toLowerCase() == \"authorization\" &&\r\n                // the request wasn't sent with a custom token\r\n                oldToken == headers[key] &&\r\n                client.authStore.token\r\n            ) {\r\n                // set the latest store token\r\n                headers[key] = client.authStore.token;\r\n                break;\r\n            }\r\n        }\r\n        sendOptions.headers = headers;\r\n\r\n        return oldBeforeSend ? oldBeforeSend(url, sendOptions) : { url, sendOptions };\r\n    };\r\n}\r\n","import { CrudService } from \"@/services/utils/CrudService\";\r\nimport { AdminModel } from \"@/services/utils/dtos\";\r\nimport { AuthOptions, CommonOptions } from \"@/services/utils/options\";\r\nimport { normalizeLegacyOptionsArgs } from \"@/services/utils/legacy\";\r\nimport { registerAutoRefresh, resetAutoRefresh } from \"@/services/utils/refresh\";\r\n\r\nexport interface AdminAuthResponse {\r\n    [key: string]: any;\r\n\r\n    token: string;\r\n    admin: AdminModel;\r\n}\r\n\r\nexport class AdminService extends CrudService<AdminModel> {\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    get baseCrudPath(): string {\r\n        return \"/api/admins\";\r\n    }\r\n\r\n    // ---------------------------------------------------------------\r\n    // Post update/delete AuthStore sync\r\n    // ---------------------------------------------------------------\r\n\r\n    /**\r\n     * @inheritdoc\r\n     *\r\n     * If the current `client.authStore.model` matches with the updated id, then\r\n     * on success the `client.authStore.model` will be updated with the result.\r\n     */\r\n    async update<T = AdminModel>(\r\n        id: string,\r\n        bodyParams?: { [key: string]: any } | FormData,\r\n        options?: CommonOptions,\r\n    ): Promise<T> {\r\n        return super.update(id, bodyParams, options).then((item) => {\r\n            // update the store state if the updated item id matches with the stored model\r\n            if (\r\n                this.client.authStore.model?.id === item.id &&\r\n                typeof this.client.authStore.model?.collectionId === \"undefined\" // is not record auth\r\n            ) {\r\n                this.client.authStore.save(this.client.authStore.token, item);\r\n            }\r\n\r\n            return item as any as T;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     *\r\n     * If the current `client.authStore.model` matches with the deleted id,\r\n     * then on success the `client.authStore` will be cleared.\r\n     */\r\n    async delete(id: string, options?: CommonOptions): Promise<boolean> {\r\n        return super.delete(id, options).then((success) => {\r\n            // clear the store state if the deleted item id matches with the stored model\r\n            if (\r\n                success &&\r\n                this.client.authStore.model?.id === id &&\r\n                typeof this.client.authStore.model?.collectionId === \"undefined\" // is not record auth\r\n            ) {\r\n                this.client.authStore.clear();\r\n            }\r\n\r\n            return success;\r\n        });\r\n    }\r\n\r\n    // ---------------------------------------------------------------\r\n    // Auth handlers\r\n    // ---------------------------------------------------------------\r\n\r\n    /**\r\n     * Prepare successful authorize response.\r\n     */\r\n    protected authResponse(responseData: any): AdminAuthResponse {\r\n        const admin = this.decode(responseData?.admin || {});\r\n\r\n        if (responseData?.token && responseData?.admin) {\r\n            this.client.authStore.save(responseData.token, admin);\r\n        }\r\n\r\n        return Object.assign({}, responseData, {\r\n            // normalize common fields\r\n            token: responseData?.token || \"\",\r\n            admin: admin,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Authenticate an admin account with its email and password\r\n     * and returns a new admin token and data.\r\n     *\r\n     * On success this method automatically updates the client's AuthStore data.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async authWithPassword(\r\n        email: string,\r\n        password: string,\r\n        options?: AuthOptions,\r\n    ): Promise<AdminAuthResponse>;\r\n\r\n    /**\r\n     * @deprecated\r\n     * Consider using authWithPassword(email, password, options?).\r\n     */\r\n    async authWithPassword(\r\n        email: string,\r\n        password: string,\r\n        body?: any,\r\n        query?: any,\r\n    ): Promise<AdminAuthResponse>;\r\n\r\n    async authWithPassword(\r\n        email: string,\r\n        password: string,\r\n        bodyOrOptions?: any,\r\n        query?: any,\r\n    ): Promise<AdminAuthResponse> {\r\n        let options: any = {\r\n            method: \"POST\",\r\n            body: {\r\n                identity: email,\r\n                password: password,\r\n            },\r\n        };\r\n\r\n        options = normalizeLegacyOptionsArgs(\r\n            \"This form of authWithPassword(email, pass, body?, query?) is deprecated. Consider replacing it with authWithPassword(email, pass, options?).\",\r\n            options,\r\n            bodyOrOptions,\r\n            query,\r\n        );\r\n\r\n        const autoRefreshThreshold = options.autoRefreshThreshold;\r\n        delete options.autoRefreshThreshold;\r\n\r\n        // not from auto refresh reauthentication\r\n        if (!options.autoRefresh) {\r\n            resetAutoRefresh(this.client);\r\n        }\r\n\r\n        let authData = await this.client.send(\r\n            this.baseCrudPath + \"/auth-with-password\",\r\n            options,\r\n        );\r\n\r\n        authData = this.authResponse(authData);\r\n\r\n        if (autoRefreshThreshold) {\r\n            registerAutoRefresh(\r\n                this.client,\r\n                autoRefreshThreshold,\r\n                () => this.authRefresh({ autoRefresh: true }),\r\n                () =>\r\n                    this.authWithPassword(\r\n                        email,\r\n                        password,\r\n                        Object.assign({ autoRefresh: true }, options),\r\n                    ),\r\n            );\r\n        }\r\n\r\n        return authData;\r\n    }\r\n\r\n    /**\r\n     * Refreshes the current admin authenticated instance and\r\n     * returns a new token and admin data.\r\n     *\r\n     * On success this method automatically updates the client's AuthStore data.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async authRefresh(options?: CommonOptions): Promise<AdminAuthResponse>;\r\n\r\n    /**\r\n     * @deprecated\r\n     * Consider using authRefresh(options?).\r\n     */\r\n    async authRefresh(body?: any, query?: any): Promise<AdminAuthResponse>;\r\n\r\n    async authRefresh(bodyOrOptions?: any, query?: any): Promise<AdminAuthResponse> {\r\n        let options: any = {\r\n            method: \"POST\",\r\n        };\r\n\r\n        options = normalizeLegacyOptionsArgs(\r\n            \"This form of authRefresh(body?, query?) is deprecated. Consider replacing it with authRefresh(options?).\",\r\n            options,\r\n            bodyOrOptions,\r\n            query,\r\n        );\r\n\r\n        return this.client\r\n            .send(this.baseCrudPath + \"/auth-refresh\", options)\r\n            .then(this.authResponse.bind(this));\r\n    }\r\n\r\n    /**\r\n     * Sends admin password reset request.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async requestPasswordReset(email: string, options?: CommonOptions): Promise<boolean>;\r\n\r\n    /**\r\n     * @deprecated\r\n     * Consider using requestPasswordReset(email, options?).\r\n     */\r\n    async requestPasswordReset(email: string, body?: any, query?: any): Promise<boolean>;\r\n\r\n    async requestPasswordReset(\r\n        email: string,\r\n        bodyOrOptions?: any,\r\n        query?: any,\r\n    ): Promise<boolean> {\r\n        let options: any = {\r\n            method: \"POST\",\r\n            body: {\r\n                email: email,\r\n            },\r\n        };\r\n\r\n        options = normalizeLegacyOptionsArgs(\r\n            \"This form of requestPasswordReset(email, body?, query?) is deprecated. Consider replacing it with requestPasswordReset(email, options?).\",\r\n            options,\r\n            bodyOrOptions,\r\n            query,\r\n        );\r\n\r\n        return this.client\r\n            .send(this.baseCrudPath + \"/request-password-reset\", options)\r\n            .then(() => true);\r\n    }\r\n\r\n    /**\r\n     * Confirms admin password reset request.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async confirmPasswordReset(\r\n        resetToken: string,\r\n        password: string,\r\n        passwordConfirm: string,\r\n        options?: CommonOptions,\r\n    ): Promise<boolean>;\r\n\r\n    /**\r\n     * @deprecated\r\n     * Consider using confirmPasswordReset(resetToken, password, passwordConfirm, options?).\r\n     */\r\n    async confirmPasswordReset(\r\n        resetToken: string,\r\n        password: string,\r\n        passwordConfirm: string,\r\n        body?: any,\r\n        query?: any,\r\n    ): Promise<boolean>;\r\n\r\n    async confirmPasswordReset(\r\n        resetToken: string,\r\n        password: string,\r\n        passwordConfirm: string,\r\n        bodyOrOptions?: any,\r\n        query?: any,\r\n    ): Promise<boolean> {\r\n        let options: any = {\r\n            method: \"POST\",\r\n            body: {\r\n                token: resetToken,\r\n                password: password,\r\n                passwordConfirm: passwordConfirm,\r\n            },\r\n        };\r\n\r\n        options = normalizeLegacyOptionsArgs(\r\n            \"This form of confirmPasswordReset(resetToken, password, passwordConfirm, body?, query?) is deprecated. Consider replacing it with confirmPasswordReset(resetToken, password, passwordConfirm, options?).\",\r\n            options,\r\n            bodyOrOptions,\r\n            query,\r\n        );\r\n\r\n        return this.client\r\n            .send(this.baseCrudPath + \"/confirm-password-reset\", options)\r\n            .then(() => true);\r\n    }\r\n}\r\n","export interface SendOptions extends RequestInit {\r\n    // for backward compatibility and to minimize the verbosity,\r\n    // any top-level field that doesn't exist in RequestInit or the\r\n    // fields below will be treated as query parameter.\r\n    [key: string]: any;\r\n\r\n    /**\r\n     * Optional custom fetch function to use for sending the request.\r\n     */\r\n    fetch?: (url: RequestInfo | URL, config?: RequestInit) => Promise<Response>;\r\n\r\n    /**\r\n     * Custom headers to send with the requests.\r\n     */\r\n    headers?: { [key: string]: string };\r\n\r\n    /**\r\n     * The body of the request (serialized automatically for json requests).\r\n     */\r\n    body?: any;\r\n\r\n    /**\r\n     * Query parameters that will be appended to the request url.\r\n     */\r\n    query?: { [key: string]: any };\r\n\r\n    /**\r\n     * @deprecated use `query` instead\r\n     *\r\n     * for backward-compatibility `params` values are merged with `query`,\r\n     * but this option may get removed in the final v1 release\r\n     */\r\n    params?: { [key: string]: any };\r\n\r\n    /**\r\n     * The request identifier that can be used to cancel pending requests.\r\n     */\r\n    requestKey?: string | null;\r\n\r\n    /**\r\n     * @deprecated use `requestKey:string` instead\r\n     */\r\n    $cancelKey?: string;\r\n\r\n    /**\r\n     * @deprecated use `requestKey:null` instead\r\n     */\r\n    $autoCancel?: boolean;\r\n}\r\n\r\nexport interface CommonOptions extends SendOptions {\r\n    fields?: string;\r\n}\r\n\r\nexport interface ListOptions extends CommonOptions {\r\n    page?: number;\r\n    perPage?: number;\r\n    sort?: string;\r\n    filter?: string;\r\n    skipTotal?: boolean;\r\n}\r\n\r\nexport interface FullListOptions extends ListOptions {\r\n    batch?: number;\r\n}\r\n\r\nexport interface RecordOptions extends CommonOptions {\r\n    expand?: string;\r\n}\r\n\r\nexport interface RecordListOptions extends ListOptions, RecordOptions {}\r\n\r\nexport interface RecordFullListOptions extends FullListOptions, RecordOptions {}\r\n\r\nexport interface LogStatsOptions extends CommonOptions {\r\n    filter?: string;\r\n}\r\n\r\nexport interface FileOptions extends CommonOptions {\r\n    thumb?: string;\r\n    download?: boolean;\r\n}\r\n\r\nexport interface AuthOptions extends CommonOptions {\r\n    /**\r\n     * If autoRefreshThreshold is set it will take care to auto refresh\r\n     * when necessary the auth data before each request to ensure that\r\n     * the auth state is always valid.\r\n     *\r\n     * The value must be in seconds, aka. the amount of seconds\r\n     * that will be subtracted from the current token `exp` claim in order\r\n     * to determine whether it is going to expire within the specified time threshold.\r\n     *\r\n     * For example, if you want to auto refresh the token if it is\r\n     * going to expire in the next 30mins (or already has expired),\r\n     * it can be set to `1800`\r\n     */\r\n    autoRefreshThreshold?: number;\r\n}\r\n\r\n// -------------------------------------------------------------------\r\n\r\n// list of known SendOptions keys (everything else is treated as query param)\r\nconst knownSendOptionsKeys = [\r\n    \"requestKey\",\r\n    \"$cancelKey\",\r\n    \"$autoCancel\",\r\n    \"fetch\",\r\n    \"headers\",\r\n    \"body\",\r\n    \"query\",\r\n    \"params\",\r\n    // ---,\r\n    \"cache\",\r\n    \"credentials\",\r\n    \"headers\",\r\n    \"integrity\",\r\n    \"keepalive\",\r\n    \"method\",\r\n    \"mode\",\r\n    \"redirect\",\r\n    \"referrer\",\r\n    \"referrerPolicy\",\r\n    \"signal\",\r\n    \"window\",\r\n];\r\n\r\n// modifies in place the provided options by moving unknown send options as query parameters.\r\nexport function normalizeUnknownQueryParams(options?: SendOptions): void {\r\n    if (!options) {\r\n        return;\r\n    }\r\n\r\n    options.query = options.query || {};\r\n    for (let key in options) {\r\n        if (knownSendOptionsKeys.includes(key)) {\r\n            continue;\r\n        }\r\n\r\n        options.query[key] = options[key];\r\n        delete options[key];\r\n    }\r\n}\r\n","import { ClientResponseError } from \"@/ClientResponseError\";\r\nimport { BaseService } from \"@/services/utils/BaseService\";\r\nimport { SendOptions, normalizeUnknownQueryParams } from \"@/services/utils/options\";\r\n\r\ninterface promiseCallbacks {\r\n    resolve: Function;\r\n    reject: Function;\r\n}\r\n\r\ntype Subscriptions = { [key: string]: Array<EventListener> };\r\n\r\nexport type UnsubscribeFunc = () => Promise<void>;\r\n\r\nexport class RealtimeService extends BaseService {\r\n    clientId: string = \"\";\r\n\r\n    private eventSource: EventSource | null = null;\r\n    private subscriptions: Subscriptions = {};\r\n    private lastSentSubscriptions: Array<string> = [];\r\n    private connectTimeoutId: any;\r\n    private maxConnectTimeout: number = 15000;\r\n    private reconnectTimeoutId: any;\r\n    private reconnectAttempts: number = 0;\r\n    private maxReconnectAttempts: number = Infinity;\r\n    private predefinedReconnectIntervals: Array<number> = [\r\n        200, 300, 500, 1000, 1200, 1500, 2000,\r\n    ];\r\n    private pendingConnects: Array<promiseCallbacks> = [];\r\n\r\n    /**\r\n     * Returns whether the realtime connection has been established.\r\n     */\r\n    get isConnected(): boolean {\r\n        return !!this.eventSource && !!this.clientId && !this.pendingConnects.length;\r\n    }\r\n\r\n    /**\r\n     * Register the subscription listener.\r\n     *\r\n     * You can subscribe multiple times to the same topic.\r\n     *\r\n     * If the SSE connection is not started yet,\r\n     * this method will also initialize it.\r\n     */\r\n    async subscribe(\r\n        topic: string,\r\n        callback: (data: any) => void,\r\n        options?: SendOptions,\r\n    ): Promise<UnsubscribeFunc> {\r\n        if (!topic) {\r\n            throw new Error(\"topic must be set.\");\r\n        }\r\n\r\n        let key = topic;\r\n\r\n        // serialize and append the topic options (if any)\r\n        if (options) {\r\n            normalizeUnknownQueryParams(options);\r\n            const serialized =\r\n                \"options=\" +\r\n                encodeURIComponent(\r\n                    JSON.stringify({ query: options.query, headers: options.headers }),\r\n                );\r\n            key += (key.includes(\"?\") ? \"&\" : \"?\") + serialized;\r\n        }\r\n\r\n        const listener = function (e: Event) {\r\n            const msgEvent = e as MessageEvent;\r\n\r\n            let data;\r\n            try {\r\n                data = JSON.parse(msgEvent?.data);\r\n            } catch {}\r\n\r\n            callback(data || {});\r\n        };\r\n\r\n        // store the listener\r\n        if (!this.subscriptions[key]) {\r\n            this.subscriptions[key] = [];\r\n        }\r\n        this.subscriptions[key].push(listener);\r\n\r\n        if (!this.isConnected) {\r\n            // initialize sse connection\r\n            await this.connect();\r\n        } else if (this.subscriptions[key].length === 1) {\r\n            // send the updated subscriptions (if it is the first for the key)\r\n            await this.submitSubscriptions();\r\n        } else {\r\n            // only register the listener\r\n            this.eventSource?.addEventListener(key, listener);\r\n        }\r\n\r\n        return async (): Promise<void> => {\r\n            return this.unsubscribeByTopicAndListener(topic, listener);\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Unsubscribe from all subscription listeners with the specified topic.\r\n     *\r\n     * If `topic` is not provided, then this method will unsubscribe\r\n     * from all active subscriptions.\r\n     *\r\n     * This method is no-op if there are no active subscriptions.\r\n     *\r\n     * The related sse connection will be autoclosed if after the\r\n     * unsubscribe operation there are no active subscriptions left.\r\n     */\r\n    async unsubscribe(topic?: string): Promise<void> {\r\n        let needToSubmit = false;\r\n\r\n        if (!topic) {\r\n            // remove all subscriptions\r\n            this.subscriptions = {};\r\n        } else {\r\n            // remove all listeners related to the topic\r\n            const subs = this.getSubscriptionsByTopic(topic);\r\n            for (let key in subs) {\r\n                if (!this.hasSubscriptionListeners(key)) {\r\n                    continue; // already unsubscribed\r\n                }\r\n\r\n                for (let listener of this.subscriptions[key]) {\r\n                    this.eventSource?.removeEventListener(key, listener);\r\n                }\r\n                delete this.subscriptions[key];\r\n\r\n                // mark for subscriptions change submit if there are no other listeners\r\n                if (!needToSubmit) {\r\n                    needToSubmit = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!this.hasSubscriptionListeners()) {\r\n            // no other active subscriptions -> close the sse connection\r\n            this.disconnect();\r\n        } else if (needToSubmit) {\r\n            await this.submitSubscriptions();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unsubscribe from all subscription listeners starting with the specified topic prefix.\r\n     *\r\n     * This method is no-op if there are no active subscriptions with the specified topic prefix.\r\n     *\r\n     * The related sse connection will be autoclosed if after the\r\n     * unsubscribe operation there are no active subscriptions left.\r\n     */\r\n    async unsubscribeByPrefix(keyPrefix: string): Promise<void> {\r\n        let hasAtleastOneTopic = false;\r\n        for (let key in this.subscriptions) {\r\n            // \"?\" so that it can be used as end delimiter for the prefix\r\n            if (!(key + \"?\").startsWith(keyPrefix)) {\r\n                continue;\r\n            }\r\n\r\n            hasAtleastOneTopic = true;\r\n            for (let listener of this.subscriptions[key]) {\r\n                this.eventSource?.removeEventListener(key, listener);\r\n            }\r\n            delete this.subscriptions[key];\r\n        }\r\n\r\n        if (!hasAtleastOneTopic) {\r\n            return; // nothing to unsubscribe from\r\n        }\r\n\r\n        if (this.hasSubscriptionListeners()) {\r\n            // submit the deleted subscriptions\r\n            await this.submitSubscriptions();\r\n        } else {\r\n            // no other active subscriptions -> close the sse connection\r\n            this.disconnect();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Unsubscribe from all subscriptions matching the specified topic and listener function.\r\n     *\r\n     * This method is no-op if there are no active subscription with\r\n     * the specified topic and listener.\r\n     *\r\n     * The related sse connection will be autoclosed if after the\r\n     * unsubscribe operation there are no active subscriptions left.\r\n     */\r\n    async unsubscribeByTopicAndListener(\r\n        topic: string,\r\n        listener: EventListener,\r\n    ): Promise<void> {\r\n        let needToSubmit = false;\r\n\r\n        const subs = this.getSubscriptionsByTopic(topic);\r\n        for (let key in subs) {\r\n            if (\r\n                !Array.isArray(this.subscriptions[key]) ||\r\n                !this.subscriptions[key].length\r\n            ) {\r\n                continue; // already unsubscribed\r\n            }\r\n\r\n            let exist = false;\r\n            for (let i = this.subscriptions[key].length - 1; i >= 0; i--) {\r\n                if (this.subscriptions[key][i] !== listener) {\r\n                    continue;\r\n                }\r\n\r\n                exist = true; // has at least one matching listener\r\n                delete this.subscriptions[key][i]; // removes the function reference\r\n                this.subscriptions[key].splice(i, 1); // reindex the array\r\n                this.eventSource?.removeEventListener(key, listener);\r\n            }\r\n            if (!exist) {\r\n                continue;\r\n            }\r\n\r\n            // remove the key from the subscriptions list if there are no other listeners\r\n            if (!this.subscriptions[key].length) {\r\n                delete this.subscriptions[key];\r\n            }\r\n\r\n            // mark for subscriptions change submit if there are no other listeners\r\n            if (!needToSubmit && !this.hasSubscriptionListeners(key)) {\r\n                needToSubmit = true;\r\n            }\r\n        }\r\n\r\n        if (!this.hasSubscriptionListeners()) {\r\n            // no other active subscriptions -> close the sse connection\r\n            this.disconnect();\r\n        } else if (needToSubmit) {\r\n            await this.submitSubscriptions();\r\n        }\r\n    }\r\n\r\n    private hasSubscriptionListeners(keyToCheck?: string): boolean {\r\n        this.subscriptions = this.subscriptions || {};\r\n\r\n        // check the specified key\r\n        if (keyToCheck) {\r\n            return !!this.subscriptions[keyToCheck]?.length;\r\n        }\r\n\r\n        // check for at least one non-empty subscription\r\n        for (let key in this.subscriptions) {\r\n            if (!!this.subscriptions[key]?.length) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private async submitSubscriptions(): Promise<void> {\r\n        if (!this.clientId) {\r\n            return; // no client/subscriber\r\n        }\r\n\r\n        // optimistic update\r\n        this.addAllSubscriptionListeners();\r\n\r\n        this.lastSentSubscriptions = this.getNonEmptySubscriptionKeys();\r\n\r\n        return this.client\r\n            .send(\"/api/realtime\", {\r\n                method: \"POST\",\r\n                body: {\r\n                    clientId: this.clientId,\r\n                    subscriptions: this.lastSentSubscriptions,\r\n                },\r\n                requestKey: this.getSubscriptionsCancelKey(),\r\n            })\r\n            .catch((err) => {\r\n                if (err?.isAbort) {\r\n                    return; // silently ignore aborted pending requests\r\n                }\r\n                throw err;\r\n            });\r\n    }\r\n\r\n    private getSubscriptionsCancelKey(): string {\r\n        return \"realtime_\" + this.clientId;\r\n    }\r\n\r\n    private getSubscriptionsByTopic(topic: string): Subscriptions {\r\n        const result: Subscriptions = {};\r\n\r\n        // \"?\" so that it can be used as end delimiter for the topic\r\n        topic = topic.includes(\"?\") ? topic : topic + \"?\";\r\n\r\n        for (let key in this.subscriptions) {\r\n            if ((key + \"?\").startsWith(topic)) {\r\n                result[key] = this.subscriptions[key];\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private getNonEmptySubscriptionKeys(): Array<string> {\r\n        const result: Array<string> = [];\r\n\r\n        for (let key in this.subscriptions) {\r\n            if (this.subscriptions[key].length) {\r\n                result.push(key);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private addAllSubscriptionListeners(): void {\r\n        if (!this.eventSource) {\r\n            return;\r\n        }\r\n\r\n        this.removeAllSubscriptionListeners();\r\n\r\n        for (let key in this.subscriptions) {\r\n            for (let listener of this.subscriptions[key]) {\r\n                this.eventSource.addEventListener(key, listener);\r\n            }\r\n        }\r\n    }\r\n\r\n    private removeAllSubscriptionListeners(): void {\r\n        if (!this.eventSource) {\r\n            return;\r\n        }\r\n\r\n        for (let key in this.subscriptions) {\r\n            for (let listener of this.subscriptions[key]) {\r\n                this.eventSource.removeEventListener(key, listener);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async connect(): Promise<void> {\r\n        if (this.reconnectAttempts > 0) {\r\n            // immediately resolve the promise to avoid indefinitely\r\n            // blocking the client during reconnection\r\n            return;\r\n        }\r\n\r\n        return new Promise((resolve, reject) => {\r\n            this.pendingConnects.push({ resolve, reject });\r\n\r\n            if (this.pendingConnects.length > 1) {\r\n                // all promises will be resolved once the connection is established\r\n                return;\r\n            }\r\n\r\n            this.initConnect();\r\n        });\r\n    }\r\n\r\n    private initConnect() {\r\n        this.disconnect(true);\r\n\r\n        // wait up to 15s for connect\r\n        clearTimeout(this.connectTimeoutId);\r\n        this.connectTimeoutId = setTimeout(() => {\r\n            this.connectErrorHandler(new Error(\"EventSource connect took too long.\"));\r\n        }, this.maxConnectTimeout);\r\n\r\n        this.eventSource = new EventSource(this.client.buildUrl(\"/api/realtime\"));\r\n\r\n        this.eventSource.onerror = (_) => {\r\n            this.connectErrorHandler(\r\n                new Error(\"Failed to establish realtime connection.\"),\r\n            );\r\n        };\r\n\r\n        this.eventSource.addEventListener(\"PB_CONNECT\", (e) => {\r\n            const msgEvent = e as MessageEvent;\r\n            this.clientId = msgEvent?.lastEventId;\r\n\r\n            this.submitSubscriptions()\r\n                .then(async () => {\r\n                    let retries = 3;\r\n                    while (this.hasUnsentSubscriptions() && retries > 0) {\r\n                        retries--;\r\n                        // resubscribe to ensure that the latest topics are submitted\r\n                        //\r\n                        // This is needed because missed topics could happen on reconnect\r\n                        // if after the pending sent `submitSubscriptions()` call another `subscribe()`\r\n                        // was made before the submit was able to complete.\r\n                        await this.submitSubscriptions();\r\n                    }\r\n                })\r\n                .then(() => {\r\n                    for (let p of this.pendingConnects) {\r\n                        p.resolve();\r\n                    }\r\n\r\n                    // reset connect meta\r\n                    this.pendingConnects = [];\r\n                    this.reconnectAttempts = 0;\r\n                    clearTimeout(this.reconnectTimeoutId);\r\n                    clearTimeout(this.connectTimeoutId);\r\n\r\n                    // propagate the PB_CONNECT event\r\n                    const connectSubs = this.getSubscriptionsByTopic(\"PB_CONNECT\");\r\n                    for (let key in connectSubs) {\r\n                        for (let listener of connectSubs[key]) {\r\n                            listener(e);\r\n                        }\r\n                    }\r\n                })\r\n                .catch((err) => {\r\n                    this.clientId = \"\";\r\n                    this.connectErrorHandler(err);\r\n                });\r\n        });\r\n    }\r\n\r\n    private hasUnsentSubscriptions(): boolean {\r\n        const latestTopics = this.getNonEmptySubscriptionKeys();\r\n        if (latestTopics.length != this.lastSentSubscriptions.length) {\r\n            return true;\r\n        }\r\n\r\n        for (const t of latestTopics) {\r\n            if (!this.lastSentSubscriptions.includes(t)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    private connectErrorHandler(err: any) {\r\n        clearTimeout(this.connectTimeoutId);\r\n        clearTimeout(this.reconnectTimeoutId);\r\n\r\n        if (\r\n            // wasn't previously connected -> direct reject\r\n            (!this.clientId && !this.reconnectAttempts) ||\r\n            // was previously connected but the max reconnection limit has been reached\r\n            this.reconnectAttempts > this.maxReconnectAttempts\r\n        ) {\r\n            for (let p of this.pendingConnects) {\r\n                p.reject(new ClientResponseError(err));\r\n            }\r\n            this.pendingConnects = [];\r\n            this.disconnect();\r\n            return;\r\n        }\r\n\r\n        // otherwise -> reconnect in the background\r\n        this.disconnect(true);\r\n        const timeout =\r\n            this.predefinedReconnectIntervals[this.reconnectAttempts] ||\r\n            this.predefinedReconnectIntervals[\r\n                this.predefinedReconnectIntervals.length - 1\r\n            ];\r\n        this.reconnectAttempts++;\r\n        this.reconnectTimeoutId = setTimeout(() => {\r\n            this.initConnect();\r\n        }, timeout);\r\n    }\r\n\r\n    private disconnect(fromReconnect = false): void {\r\n        clearTimeout(this.connectTimeoutId);\r\n        clearTimeout(this.reconnectTimeoutId);\r\n        this.removeAllSubscriptionListeners();\r\n        this.client.cancelRequest(this.getSubscriptionsCancelKey());\r\n        this.eventSource?.close();\r\n        this.eventSource = null;\r\n        this.clientId = \"\";\r\n\r\n        if (!fromReconnect) {\r\n            this.reconnectAttempts = 0;\r\n\r\n            // resolve any remaining connect promises\r\n            //\r\n            // this is done to avoid unnecessary throwing errors in case\r\n            // unsubscribe is called before the pending connect promises complete\r\n            // (see https://github.com/pocketbase/pocketbase/discussions/2897#discussioncomment-6423818)\r\n            for (let p of this.pendingConnects) {\r\n                p.resolve();\r\n            }\r\n            this.pendingConnects = [];\r\n        }\r\n    }\r\n}\r\n","import Client from \"@/Client\";\r\nimport { getTokenPayload } from \"@/stores/utils/jwt\";\r\nimport { CrudService } from \"@/services/utils/CrudService\";\r\nimport { RealtimeService, UnsubscribeFunc } from \"@/services/RealtimeService\";\r\nimport { ClientResponseError } from \"@/ClientResponseError\";\r\nimport { ListResult, RecordModel, ExternalAuthModel } from \"@/services/utils/dtos\";\r\nimport {\r\n    SendOptions,\r\n    CommonOptions,\r\n    RecordOptions,\r\n    RecordListOptions,\r\n    RecordFullListOptions,\r\n} from \"@/services/utils/options\";\r\nimport { normalizeLegacyOptionsArgs } from \"@/services/utils/legacy\";\r\n\r\nexport interface RecordAuthResponse<T = RecordModel> {\r\n    /**\r\n     * The signed PocketBase auth record.\r\n     */\r\n    record: T;\r\n\r\n    /**\r\n     * The PocketBase record auth token.\r\n     *\r\n     * If you are looking for the OAuth2 access and refresh tokens\r\n     * they are available under the `meta.accessToken` and `meta.refreshToken` props.\r\n     */\r\n    token: string;\r\n\r\n    /**\r\n     * Auth meta data usually filled when OAuth2 is used.\r\n     */\r\n    meta?: { [key: string]: any };\r\n}\r\n\r\nexport interface AuthProviderInfo {\r\n    name: string;\r\n    displayName: string;\r\n    state: string;\r\n    authUrl: string;\r\n    codeVerifier: string;\r\n    codeChallenge: string;\r\n    codeChallengeMethod: string;\r\n}\r\n\r\nexport interface AuthMethodsList {\r\n    usernamePassword: boolean;\r\n    emailPassword: boolean;\r\n    onlyVerified: boolean;\r\n    authProviders: Array<AuthProviderInfo>;\r\n}\r\n\r\nexport interface RecordSubscription<T = RecordModel> {\r\n    action: string; // eg. create, update, delete\r\n    record: T;\r\n}\r\n\r\nexport type OAuth2UrlCallback = (url: string) => void | Promise<void>;\r\n\r\nexport interface OAuth2AuthConfig extends SendOptions {\r\n    // the name of the OAuth2 provider (eg. \"google\")\r\n    provider: string;\r\n\r\n    // custom scopes to overwrite the default ones\r\n    scopes?: Array<string>;\r\n\r\n    // optional record create data\r\n    createData?: { [key: string]: any };\r\n\r\n    // optional callback that is triggered after the OAuth2 sign-in/sign-up url generation\r\n    urlCallback?: OAuth2UrlCallback;\r\n\r\n    // optional query params to send with the PocketBase auth request (eg. fields, expand, etc.)\r\n    query?: RecordOptions;\r\n}\r\n\r\nexport class RecordService<M = RecordModel> extends CrudService<M> {\r\n    readonly collectionIdOrName: string;\r\n\r\n    constructor(client: Client, collectionIdOrName: string) {\r\n        super(client);\r\n\r\n        this.collectionIdOrName = collectionIdOrName;\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    get baseCrudPath(): string {\r\n        return this.baseCollectionPath + \"/records\";\r\n    }\r\n\r\n    /**\r\n     * Returns the current collection service base path.\r\n     */\r\n    get baseCollectionPath(): string {\r\n        return \"/api/collections/\" + encodeURIComponent(this.collectionIdOrName);\r\n    }\r\n\r\n    // ---------------------------------------------------------------\r\n    // Realtime handlers\r\n    // ---------------------------------------------------------------\r\n\r\n    /**\r\n     * Subscribe to realtime changes to the specified topic (\"*\" or record id).\r\n     *\r\n     * If `topic` is the wildcard \"*\", then this method will subscribe to\r\n     * any record changes in the collection.\r\n     *\r\n     * If `topic` is a record id, then this method will subscribe only\r\n     * to changes of the specified record id.\r\n     *\r\n     * It's OK to subscribe multiple times to the same topic.\r\n     * You can use the returned `UnsubscribeFunc` to remove only a single subscription.\r\n     * Or use `unsubscribe(topic)` if you want to remove all subscriptions attached to the topic.\r\n     */\r\n    async subscribe<T = M>(\r\n        topic: string,\r\n        callback: (data: RecordSubscription<T>) => void,\r\n        options?: SendOptions,\r\n    ): Promise<UnsubscribeFunc> {\r\n        if (!topic) {\r\n            throw new Error(\"Missing topic.\");\r\n        }\r\n\r\n        if (!callback) {\r\n            throw new Error(\"Missing subscription callback.\");\r\n        }\r\n\r\n        return this.client.realtime.subscribe(\r\n            this.collectionIdOrName + \"/\" + topic,\r\n            callback,\r\n            options,\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Unsubscribe from all subscriptions of the specified topic\r\n     * (\"*\" or record id).\r\n     *\r\n     * If `topic` is not set, then this method will unsubscribe from\r\n     * all subscriptions associated to the current collection.\r\n     */\r\n    async unsubscribe(topic?: string): Promise<void> {\r\n        // unsubscribe from the specified topic\r\n        if (topic) {\r\n            return this.client.realtime.unsubscribe(\r\n                this.collectionIdOrName + \"/\" + topic,\r\n            );\r\n        }\r\n\r\n        // unsubscribe from everything related to the collection\r\n        return this.client.realtime.unsubscribeByPrefix(this.collectionIdOrName);\r\n    }\r\n\r\n    // ---------------------------------------------------------------\r\n    // Crud handers\r\n    // ---------------------------------------------------------------\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    async getFullList<T = M>(options?: RecordFullListOptions): Promise<Array<T>>;\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    async getFullList<T = M>(\r\n        batch?: number,\r\n        options?: RecordListOptions,\r\n    ): Promise<Array<T>>;\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    async getFullList<T = M>(\r\n        batchOrOptions?: number | RecordFullListOptions,\r\n        options?: RecordListOptions,\r\n    ): Promise<Array<T>> {\r\n        if (typeof batchOrOptions == \"number\") {\r\n            return super.getFullList<T>(batchOrOptions, options);\r\n        }\r\n\r\n        const params = Object.assign({}, batchOrOptions, options);\r\n\r\n        return super.getFullList<T>(params);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    async getList<T = M>(\r\n        page = 1,\r\n        perPage = 30,\r\n        options?: RecordListOptions,\r\n    ): Promise<ListResult<T>> {\r\n        return super.getList<T>(page, perPage, options);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    async getFirstListItem<T = M>(\r\n        filter: string,\r\n        options?: RecordListOptions,\r\n    ): Promise<T> {\r\n        return super.getFirstListItem<T>(filter, options);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    async getOne<T = M>(id: string, options?: RecordOptions): Promise<T> {\r\n        return super.getOne<T>(id, options);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    async create<T = M>(\r\n        bodyParams?: { [key: string]: any } | FormData,\r\n        options?: RecordOptions,\r\n    ): Promise<T> {\r\n        return super.create<T>(bodyParams, options);\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     *\r\n     * If the current `client.authStore.model` matches with the updated id, then\r\n     * on success the `client.authStore.model` will be updated with the result.\r\n     */\r\n    async update<T = M>(\r\n        id: string,\r\n        bodyParams?: { [key: string]: any } | FormData,\r\n        options?: RecordOptions,\r\n    ): Promise<T> {\r\n        return super.update<RecordModel>(id, bodyParams, options).then((item) => {\r\n            if (\r\n                // is record auth\r\n                this.client.authStore.model?.id === item?.id &&\r\n                (this.client.authStore.model?.collectionId === this.collectionIdOrName ||\r\n                    this.client.authStore.model?.collectionName ===\r\n                        this.collectionIdOrName)\r\n            ) {\r\n                this.client.authStore.save(this.client.authStore.token, item);\r\n            }\r\n\r\n            return item as any as T;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     *\r\n     * If the current `client.authStore.model` matches with the deleted id,\r\n     * then on success the `client.authStore` will be cleared.\r\n     */\r\n    async delete(id: string, options?: CommonOptions): Promise<boolean> {\r\n        return super.delete(id, options).then((success) => {\r\n            if (\r\n                success &&\r\n                // is record auth\r\n                this.client.authStore.model?.id === id &&\r\n                (this.client.authStore.model?.collectionId === this.collectionIdOrName ||\r\n                    this.client.authStore.model?.collectionName ===\r\n                        this.collectionIdOrName)\r\n            ) {\r\n                this.client.authStore.clear();\r\n            }\r\n\r\n            return success;\r\n        });\r\n    }\r\n\r\n    // ---------------------------------------------------------------\r\n    // Auth handlers\r\n    // ---------------------------------------------------------------\r\n\r\n    /**\r\n     * Prepare successful collection authorization response.\r\n     */\r\n    protected authResponse<T = M>(responseData: any): RecordAuthResponse<T> {\r\n        const record = this.decode(responseData?.record || {});\r\n\r\n        this.client.authStore.save(responseData?.token, record as any);\r\n\r\n        return Object.assign({}, responseData, {\r\n            // normalize common fields\r\n            token: responseData?.token || \"\",\r\n            record: record as any as T,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns all available collection auth methods.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async listAuthMethods(options?: CommonOptions): Promise<AuthMethodsList> {\r\n        options = Object.assign(\r\n            {\r\n                method: \"GET\",\r\n            },\r\n            options,\r\n        );\r\n\r\n        return this.client\r\n            .send(this.baseCollectionPath + \"/auth-methods\", options)\r\n            .then((responseData: any) => {\r\n                return Object.assign({}, responseData, {\r\n                    // normalize common fields\r\n                    usernamePassword: !!responseData?.usernamePassword,\r\n                    emailPassword: !!responseData?.emailPassword,\r\n                    authProviders: Array.isArray(responseData?.authProviders)\r\n                        ? responseData?.authProviders\r\n                        : [],\r\n                });\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Authenticate a single auth collection record via its username/email and password.\r\n     *\r\n     * On success, this method also automatically updates\r\n     * the client's AuthStore data and returns:\r\n     * - the authentication token\r\n     * - the authenticated record model\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async authWithPassword<T = M>(\r\n        usernameOrEmail: string,\r\n        password: string,\r\n        options?: RecordOptions,\r\n    ): Promise<RecordAuthResponse<T>>;\r\n\r\n    /**\r\n     * @deprecated\r\n     * Consider using authWithPassword(usernameOrEmail, password, options?).\r\n     */\r\n    async authWithPassword<T = M>(\r\n        usernameOrEmail: string,\r\n        password: string,\r\n        body?: any,\r\n        query?: any,\r\n    ): Promise<RecordAuthResponse<T>>;\r\n\r\n    async authWithPassword<T = M>(\r\n        usernameOrEmail: string,\r\n        password: string,\r\n        bodyOrOptions?: any,\r\n        query?: any,\r\n    ): Promise<RecordAuthResponse<T>> {\r\n        let options: any = {\r\n            method: \"POST\",\r\n            body: {\r\n                identity: usernameOrEmail,\r\n                password: password,\r\n            },\r\n        };\r\n\r\n        options = normalizeLegacyOptionsArgs(\r\n            \"This form of authWithPassword(usernameOrEmail, pass, body?, query?) is deprecated. Consider replacing it with authWithPassword(usernameOrEmail, pass, options?).\",\r\n            options,\r\n            bodyOrOptions,\r\n            query,\r\n        );\r\n\r\n        return this.client\r\n            .send(this.baseCollectionPath + \"/auth-with-password\", options)\r\n            .then((data) => this.authResponse<T>(data));\r\n    }\r\n\r\n    /**\r\n     * Authenticate a single auth collection record with OAuth2 code.\r\n     *\r\n     * If you don't have an OAuth2 code you may also want to check `authWithOAuth2` method.\r\n     *\r\n     * On success, this method also automatically updates\r\n     * the client's AuthStore data and returns:\r\n     * - the authentication token\r\n     * - the authenticated record model\r\n     * - the OAuth2 account data (eg. name, email, avatar, etc.)\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async authWithOAuth2Code<T = M>(\r\n        provider: string,\r\n        code: string,\r\n        codeVerifier: string,\r\n        redirectUrl: string,\r\n        createData?: { [key: string]: any },\r\n        options?: RecordOptions,\r\n    ): Promise<RecordAuthResponse<T>>;\r\n\r\n    /**\r\n     * @deprecated\r\n     * Consider using authWithOAuth2Code(provider, code, codeVerifier, redirectUrl, createdData, options?).\r\n     */\r\n    async authWithOAuth2Code<T = M>(\r\n        provider: string,\r\n        code: string,\r\n        codeVerifier: string,\r\n        redirectUrl: string,\r\n        createData?: { [key: string]: any },\r\n        body?: any,\r\n        query?: any,\r\n    ): Promise<RecordAuthResponse<T>>;\r\n\r\n    async authWithOAuth2Code<T = M>(\r\n        provider: string,\r\n        code: string,\r\n        codeVerifier: string,\r\n        redirectUrl: string,\r\n        createData?: { [key: string]: any },\r\n        bodyOrOptions?: any,\r\n        query?: any,\r\n    ): Promise<RecordAuthResponse<T>> {\r\n        let options: any = {\r\n            method: \"POST\",\r\n            body: {\r\n                provider: provider,\r\n                code: code,\r\n                codeVerifier: codeVerifier,\r\n                redirectUrl: redirectUrl,\r\n                createData: createData,\r\n            },\r\n        };\r\n\r\n        options = normalizeLegacyOptionsArgs(\r\n            \"This form of authWithOAuth2Code(provider, code, codeVerifier, redirectUrl, createData?, body?, query?) is deprecated. Consider replacing it with authWithOAuth2Code(provider, code, codeVerifier, redirectUrl, createData?, options?).\",\r\n            options,\r\n            bodyOrOptions,\r\n            query,\r\n        );\r\n\r\n        return this.client\r\n            .send(this.baseCollectionPath + \"/auth-with-oauth2\", options)\r\n            .then((data) => this.authResponse<T>(data));\r\n    }\r\n\r\n    /**\r\n     * @deprecated This form of authWithOAuth2 is deprecated.\r\n     *\r\n     * Please use `authWithOAuth2Code()` OR its simplified realtime version\r\n     * as shown in https://pocketbase.io/docs/authentication/#oauth2-integration.\r\n     */\r\n    async authWithOAuth2<T = M>(\r\n        provider: string,\r\n        code: string,\r\n        codeVerifier: string,\r\n        redirectUrl: string,\r\n        createData?: { [key: string]: any },\r\n        bodyParams?: { [key: string]: any },\r\n        queryParams?: RecordOptions,\r\n    ): Promise<RecordAuthResponse<T>>;\r\n\r\n    /**\r\n     * Authenticate a single auth collection record with OAuth2\r\n     * **without custom redirects, deeplinks or even page reload**.\r\n     *\r\n     * This method initializes a one-off realtime subscription and will\r\n     * open a popup window with the OAuth2 vendor page to authenticate.\r\n     * Once the external OAuth2 sign-in/sign-up flow is completed, the popup\r\n     * window will be automatically closed and the OAuth2 data sent back\r\n     * to the user through the previously established realtime connection.\r\n     *\r\n     * You can specify an optional `urlCallback` prop to customize\r\n     * the default url `window.open` behavior.\r\n     *\r\n     * On success, this method also automatically updates\r\n     * the client's AuthStore data and returns:\r\n     * - the authentication token\r\n     * - the authenticated record model\r\n     * - the OAuth2 account data (eg. name, email, avatar, etc.)\r\n     *\r\n     * Example:\r\n     *\r\n     * ```js\r\n     * const authData = await pb.collection(\"users\").authWithOAuth2({\r\n     *     provider: \"google\",\r\n     * })\r\n     * ```\r\n     *\r\n     * _Site-note_: when creating the OAuth2 app in the provider dashboard\r\n     * you have to configure `https://yourdomain.com/api/oauth2-redirect`\r\n     * as redirect URL.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async authWithOAuth2<T = M>(\r\n        options: OAuth2AuthConfig,\r\n    ): Promise<RecordAuthResponse<T>>;\r\n\r\n    async authWithOAuth2<T = M>(...args: any): Promise<RecordAuthResponse<T>> {\r\n        // fallback to legacy format\r\n        if (args.length > 1 || typeof args?.[0] === \"string\") {\r\n            console.warn(\r\n                \"PocketBase: This form of authWithOAuth2() is deprecated and may get removed in the future. Please replace with authWithOAuth2Code() OR use the authWithOAuth2() realtime form as shown in https://pocketbase.io/docs/authentication/#oauth2-integration.\",\r\n            );\r\n            return this.authWithOAuth2Code<T>(\r\n                args?.[0] || \"\",\r\n                args?.[1] || \"\",\r\n                args?.[2] || \"\",\r\n                args?.[3] || \"\",\r\n                args?.[4] || {},\r\n                args?.[5] || {},\r\n                args?.[6] || {},\r\n            );\r\n        }\r\n\r\n        const config = args?.[0] || {};\r\n\r\n        const authMethods = await this.listAuthMethods();\r\n\r\n        const provider = authMethods.authProviders.find(\r\n            (p) => p.name === config.provider,\r\n        );\r\n        if (!provider) {\r\n            throw new ClientResponseError(\r\n                new Error(`Missing or invalid provider \"${config.provider}\".`),\r\n            );\r\n        }\r\n\r\n        const redirectUrl = this.client.buildUrl(\"/api/oauth2-redirect\");\r\n\r\n        // initialize a one-off realtime service\r\n        const realtime = new RealtimeService(this.client);\r\n\r\n        // open a new popup window in case config.urlCallback is not set\r\n        //\r\n        // note: it is opened before the async call due to Safari restrictions\r\n        // (see https://github.com/pocketbase/pocketbase/discussions/2429#discussioncomment-5943061)\r\n        let eagerDefaultPopup: Window | null = null;\r\n        if (!config.urlCallback) {\r\n            eagerDefaultPopup = openBrowserPopup(undefined);\r\n        }\r\n\r\n        function cleanup() {\r\n            eagerDefaultPopup?.close();\r\n            realtime.unsubscribe();\r\n        }\r\n\r\n        return new Promise(async (resolve, reject) => {\r\n            try {\r\n                await realtime.subscribe(\"@oauth2\", async (e) => {\r\n                    const oldState = realtime.clientId;\r\n\r\n                    try {\r\n                        if (!e.state || oldState !== e.state) {\r\n                            throw new Error(\"State parameters don't match.\");\r\n                        }\r\n\r\n                        if (e.error || !e.code) {\r\n                            throw new Error(\r\n                                \"OAuth2 redirect error or missing code: \" + e.error,\r\n                            );\r\n                        }\r\n\r\n                        // clear the non SendOptions props\r\n                        const options = Object.assign({}, config);\r\n                        delete options.provider;\r\n                        delete options.scopes;\r\n                        delete options.createData;\r\n                        delete options.urlCallback;\r\n\r\n                        const authData = await this.authWithOAuth2Code<T>(\r\n                            provider.name,\r\n                            e.code,\r\n                            provider.codeVerifier,\r\n                            redirectUrl,\r\n                            config.createData,\r\n                            options,\r\n                        );\r\n\r\n                        resolve(authData);\r\n                    } catch (err) {\r\n                        reject(new ClientResponseError(err));\r\n                    }\r\n\r\n                    cleanup();\r\n                });\r\n\r\n                const replacements: { [key: string]: any } = {\r\n                    state: realtime.clientId,\r\n                };\r\n                if (config.scopes?.length) {\r\n                    replacements[\"scope\"] = config.scopes.join(\" \");\r\n                }\r\n\r\n                const url = this._replaceQueryParams(\r\n                    provider.authUrl + redirectUrl,\r\n                    replacements,\r\n                );\r\n\r\n                let urlCallback =\r\n                    config.urlCallback ||\r\n                    function (url: string) {\r\n                        if (eagerDefaultPopup) {\r\n                            eagerDefaultPopup.location.href = url;\r\n                        } else {\r\n                            // it could have been blocked due to its empty initial url,\r\n                            // try again...\r\n                            eagerDefaultPopup = openBrowserPopup(url);\r\n                        }\r\n                    };\r\n\r\n                await urlCallback(url);\r\n            } catch (err) {\r\n                cleanup();\r\n                reject(new ClientResponseError(err));\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Refreshes the current authenticated record instance and\r\n     * returns a new token and record data.\r\n     *\r\n     * On success this method also automatically updates the client's AuthStore.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async authRefresh<T = M>(options?: RecordOptions): Promise<RecordAuthResponse<T>>;\r\n\r\n    /**\r\n     * @deprecated\r\n     * Consider using authRefresh(options?).\r\n     */\r\n    async authRefresh<T = M>(body?: any, query?: any): Promise<RecordAuthResponse<T>>;\r\n\r\n    async authRefresh<T = M>(\r\n        bodyOrOptions?: any,\r\n        query?: any,\r\n    ): Promise<RecordAuthResponse<T>> {\r\n        let options: any = {\r\n            method: \"POST\",\r\n        };\r\n\r\n        options = normalizeLegacyOptionsArgs(\r\n            \"This form of authRefresh(body?, query?) is deprecated. Consider replacing it with authRefresh(options?).\",\r\n            options,\r\n            bodyOrOptions,\r\n            query,\r\n        );\r\n\r\n        return this.client\r\n            .send(this.baseCollectionPath + \"/auth-refresh\", options)\r\n            .then((data) => this.authResponse<T>(data));\r\n    }\r\n\r\n    /**\r\n     * Sends auth record password reset request.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async requestPasswordReset(email: string, options?: CommonOptions): Promise<boolean>;\r\n\r\n    /**\r\n     * @deprecated\r\n     * Consider using requestPasswordReset(email, options?).\r\n     */\r\n    async requestPasswordReset(email: string, body?: any, query?: any): Promise<boolean>;\r\n\r\n    async requestPasswordReset(\r\n        email: string,\r\n        bodyOrOptions?: any,\r\n        query?: any,\r\n    ): Promise<boolean> {\r\n        let options: any = {\r\n            method: \"POST\",\r\n            body: {\r\n                email: email,\r\n            },\r\n        };\r\n\r\n        options = normalizeLegacyOptionsArgs(\r\n            \"This form of requestPasswordReset(email, body?, query?) is deprecated. Consider replacing it with requestPasswordReset(email, options?).\",\r\n            options,\r\n            bodyOrOptions,\r\n            query,\r\n        );\r\n\r\n        return this.client\r\n            .send(this.baseCollectionPath + \"/request-password-reset\", options)\r\n            .then(() => true);\r\n    }\r\n\r\n    /**\r\n     * Confirms auth record password reset request.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async confirmPasswordReset(\r\n        passwordResetToken: string,\r\n        password: string,\r\n        passwordConfirm: string,\r\n        options?: CommonOptions,\r\n    ): Promise<boolean>;\r\n\r\n    /**\r\n     * @deprecated\r\n     * Consider using confirmPasswordReset(passwordResetToken, password, passwordConfirm, options?).\r\n     */\r\n    async confirmPasswordReset(\r\n        passwordResetToken: string,\r\n        password: string,\r\n        passwordConfirm: string,\r\n        body?: any,\r\n        query?: any,\r\n    ): Promise<boolean>;\r\n\r\n    async confirmPasswordReset(\r\n        passwordResetToken: string,\r\n        password: string,\r\n        passwordConfirm: string,\r\n        bodyOrOptions?: any,\r\n        query?: any,\r\n    ): Promise<boolean> {\r\n        let options: any = {\r\n            method: \"POST\",\r\n            body: {\r\n                token: passwordResetToken,\r\n                password: password,\r\n                passwordConfirm: passwordConfirm,\r\n            },\r\n        };\r\n\r\n        options = normalizeLegacyOptionsArgs(\r\n            \"This form of confirmPasswordReset(token, password, passwordConfirm, body?, query?) is deprecated. Consider replacing it with confirmPasswordReset(token, password, passwordConfirm, options?).\",\r\n            options,\r\n            bodyOrOptions,\r\n            query,\r\n        );\r\n\r\n        return this.client\r\n            .send(this.baseCollectionPath + \"/confirm-password-reset\", options)\r\n            .then(() => true);\r\n    }\r\n\r\n    /**\r\n     * Sends auth record verification email request.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async requestVerification(email: string, options?: CommonOptions): Promise<boolean>;\r\n\r\n    /**\r\n     * @deprecated\r\n     * Consider using requestVerification(email, options?).\r\n     */\r\n    async requestVerification(email: string, body?: any, query?: any): Promise<boolean>;\r\n\r\n    async requestVerification(\r\n        email: string,\r\n        bodyOrOptions?: any,\r\n        query?: any,\r\n    ): Promise<boolean> {\r\n        let options: any = {\r\n            method: \"POST\",\r\n            body: {\r\n                email: email,\r\n            },\r\n        };\r\n\r\n        options = normalizeLegacyOptionsArgs(\r\n            \"This form of requestVerification(email, body?, query?) is deprecated. Consider replacing it with requestVerification(email, options?).\",\r\n            options,\r\n            bodyOrOptions,\r\n            query,\r\n        );\r\n\r\n        return this.client\r\n            .send(this.baseCollectionPath + \"/request-verification\", options)\r\n            .then(() => true);\r\n    }\r\n\r\n    /**\r\n     * Confirms auth record email verification request.\r\n     *\r\n     * If the current `client.authStore.model` matches with the auth record from the token,\r\n     * then on success the `client.authStore.model.verified` will be updated to `true`.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async confirmVerification(\r\n        verificationToken: string,\r\n        options?: CommonOptions,\r\n    ): Promise<boolean>;\r\n\r\n    /**\r\n     * @deprecated\r\n     * Consider using confirmVerification(verificationToken, options?).\r\n     */\r\n    async confirmVerification(\r\n        verificationToken: string,\r\n        body?: any,\r\n        query?: any,\r\n    ): Promise<boolean>;\r\n\r\n    async confirmVerification(\r\n        verificationToken: string,\r\n        bodyOrOptions?: any,\r\n        query?: any,\r\n    ): Promise<boolean> {\r\n        let options: any = {\r\n            method: \"POST\",\r\n            body: {\r\n                token: verificationToken,\r\n            },\r\n        };\r\n\r\n        options = normalizeLegacyOptionsArgs(\r\n            \"This form of confirmVerification(token, body?, query?) is deprecated. Consider replacing it with confirmVerification(token, options?).\",\r\n            options,\r\n            bodyOrOptions,\r\n            query,\r\n        );\r\n\r\n        return this.client\r\n            .send(this.baseCollectionPath + \"/confirm-verification\", options)\r\n            .then(() => {\r\n                // on success manually update the current auth record verified state\r\n                const payload = getTokenPayload(verificationToken);\r\n                const model = this.client.authStore.model;\r\n                if (\r\n                    model &&\r\n                    !model.verified &&\r\n                    model.id === payload.id &&\r\n                    model.collectionId === payload.collectionId\r\n                ) {\r\n                    model.verified = true;\r\n                    this.client.authStore.save(this.client.authStore.token, model);\r\n                }\r\n\r\n                return true;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Sends an email change request to the authenticated record model.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async requestEmailChange(newEmail: string, options?: CommonOptions): Promise<boolean>;\r\n\r\n    /**\r\n     * @deprecated\r\n     * Consider using requestEmailChange(newEmail, options?).\r\n     */\r\n    async requestEmailChange(newEmail: string, body?: any, query?: any): Promise<boolean>;\r\n\r\n    async requestEmailChange(\r\n        newEmail: string,\r\n        bodyOrOptions?: any,\r\n        query?: any,\r\n    ): Promise<boolean> {\r\n        let options: any = {\r\n            method: \"POST\",\r\n            body: {\r\n                newEmail: newEmail,\r\n            },\r\n        };\r\n\r\n        options = normalizeLegacyOptionsArgs(\r\n            \"This form of requestEmailChange(newEmail, body?, query?) is deprecated. Consider replacing it with requestEmailChange(newEmail, options?).\",\r\n            options,\r\n            bodyOrOptions,\r\n            query,\r\n        );\r\n\r\n        return this.client\r\n            .send(this.baseCollectionPath + \"/request-email-change\", options)\r\n            .then(() => true);\r\n    }\r\n\r\n    /**\r\n     * Confirms auth record's new email address.\r\n     *\r\n     * If the current `client.authStore.model` matches with the auth record from the token,\r\n     * then on success the `client.authStore` will be cleared.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async confirmEmailChange(\r\n        emailChangeToken: string,\r\n        password: string,\r\n        options?: CommonOptions,\r\n    ): Promise<boolean>;\r\n\r\n    /**\r\n     * @deprecated\r\n     * Consider using confirmEmailChange(emailChangeToken, password, options?).\r\n     */\r\n    async confirmEmailChange(\r\n        emailChangeToken: string,\r\n        password: string,\r\n        body?: any,\r\n        query?: any,\r\n    ): Promise<boolean>;\r\n\r\n    async confirmEmailChange(\r\n        emailChangeToken: string,\r\n        password: string,\r\n        bodyOrOptions?: any,\r\n        query?: any,\r\n    ): Promise<boolean> {\r\n        let options: any = {\r\n            method: \"POST\",\r\n            body: {\r\n                token: emailChangeToken,\r\n                password: password,\r\n            },\r\n        };\r\n\r\n        options = normalizeLegacyOptionsArgs(\r\n            \"This form of confirmEmailChange(token, password, body?, query?) is deprecated. Consider replacing it with confirmEmailChange(token, password, options?).\",\r\n            options,\r\n            bodyOrOptions,\r\n            query,\r\n        );\r\n\r\n        return this.client\r\n            .send(this.baseCollectionPath + \"/confirm-email-change\", options)\r\n            .then(() => {\r\n                const payload = getTokenPayload(emailChangeToken);\r\n                const model = this.client.authStore.model;\r\n                if (\r\n                    model &&\r\n                    model.id === payload.id &&\r\n                    model.collectionId === payload.collectionId\r\n                ) {\r\n                    this.client.authStore.clear();\r\n                }\r\n\r\n                return true;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Lists all linked external auth providers for the specified auth record.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async listExternalAuths(\r\n        recordId: string,\r\n        options?: CommonOptions,\r\n    ): Promise<Array<ExternalAuthModel>> {\r\n        options = Object.assign(\r\n            {\r\n                method: \"GET\",\r\n            },\r\n            options,\r\n        );\r\n\r\n        return this.client.send(\r\n            this.baseCrudPath + \"/\" + encodeURIComponent(recordId) + \"/external-auths\",\r\n            options,\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Unlink a single external auth provider from the specified auth record.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async unlinkExternalAuth(\r\n        recordId: string,\r\n        provider: string,\r\n        options?: CommonOptions,\r\n    ): Promise<boolean> {\r\n        options = Object.assign(\r\n            {\r\n                method: \"DELETE\",\r\n            },\r\n            options,\r\n        );\r\n\r\n        return this.client\r\n            .send(\r\n                this.baseCrudPath +\r\n                    \"/\" +\r\n                    encodeURIComponent(recordId) +\r\n                    \"/external-auths/\" +\r\n                    encodeURIComponent(provider),\r\n                options,\r\n            )\r\n            .then(() => true);\r\n    }\r\n\r\n    // ---------------------------------------------------------------\r\n\r\n    // very rudimentary url query params replacement because at the moment\r\n    // URL (and URLSearchParams) doesn't seem to be fully supported in React Native\r\n    //\r\n    // note: for details behind some of the decode/encode parsing check https://unixpapa.com/js/querystring.html\r\n    private _replaceQueryParams(\r\n        url: string,\r\n        replacements: { [key: string]: any } = {},\r\n    ): string {\r\n        let urlPath = url;\r\n        let query = \"\";\r\n\r\n        const queryIndex = url.indexOf(\"?\");\r\n        if (queryIndex >= 0) {\r\n            urlPath = url.substring(0, url.indexOf(\"?\"));\r\n            query = url.substring(url.indexOf(\"?\") + 1);\r\n        }\r\n\r\n        const parsedParams: { [key: string]: string } = {};\r\n\r\n        // parse the query parameters\r\n        const rawParams = query.split(\"&\");\r\n        for (const param of rawParams) {\r\n            if (param == \"\") {\r\n                continue;\r\n            }\r\n\r\n            const pair = param.split(\"=\");\r\n            parsedParams[decodeURIComponent(pair[0].replace(/\\+/g, \" \"))] =\r\n                decodeURIComponent((pair[1] || \"\").replace(/\\+/g, \" \"));\r\n        }\r\n\r\n        // apply the replacements\r\n        for (let key in replacements) {\r\n            if (!replacements.hasOwnProperty(key)) {\r\n                continue;\r\n            }\r\n\r\n            if (replacements[key] == null) {\r\n                delete parsedParams[key];\r\n            } else {\r\n                parsedParams[key] = replacements[key];\r\n            }\r\n        }\r\n\r\n        // construct back the full query string\r\n        query = \"\";\r\n        for (let key in parsedParams) {\r\n            if (!parsedParams.hasOwnProperty(key)) {\r\n                continue;\r\n            }\r\n\r\n            if (query != \"\") {\r\n                query += \"&\";\r\n            }\r\n\r\n            query +=\r\n                encodeURIComponent(key.replace(/%20/g, \"+\")) +\r\n                \"=\" +\r\n                encodeURIComponent(parsedParams[key].replace(/%20/g, \"+\"));\r\n        }\r\n\r\n        return query != \"\" ? urlPath + \"?\" + query : urlPath;\r\n    }\r\n}\r\n\r\nfunction openBrowserPopup(url?: string): Window | null {\r\n    if (typeof window === \"undefined\" || !window?.open) {\r\n        throw new ClientResponseError(\r\n            new Error(\r\n                `Not in a browser context - please pass a custom urlCallback function.`,\r\n            ),\r\n        );\r\n    }\r\n\r\n    let width = 1024;\r\n    let height = 768;\r\n\r\n    let windowWidth = window.innerWidth;\r\n    let windowHeight = window.innerHeight;\r\n\r\n    // normalize window size\r\n    width = width > windowWidth ? windowWidth : width;\r\n    height = height > windowHeight ? windowHeight : height;\r\n\r\n    let left = windowWidth / 2 - width / 2;\r\n    let top = windowHeight / 2 - height / 2;\r\n\r\n    // note: we don't use the noopener and noreferrer attributes since\r\n    // for some reason browser blocks such windows then url is undefined/blank\r\n    return window.open(\r\n        url,\r\n        \"popup_window\",\r\n        \"width=\" +\r\n            width +\r\n            \",height=\" +\r\n            height +\r\n            \",top=\" +\r\n            top +\r\n            \",left=\" +\r\n            left +\r\n            \",resizable,menubar=no\",\r\n    );\r\n}\r\n","import { CrudService } from \"@/services/utils/CrudService\";\r\nimport { CollectionModel } from \"@/services/utils/dtos\";\r\nimport { CommonOptions } from \"@/services/utils/options\";\r\n\r\nexport class CollectionService extends CrudService<CollectionModel> {\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    get baseCrudPath(): string {\r\n        return \"/api/collections\";\r\n    }\r\n\r\n    /**\r\n     * Imports the provided collections.\r\n     *\r\n     * If `deleteMissing` is `true`, all local collections and schema fields,\r\n     * that are not present in the imported configuration, WILL BE DELETED\r\n     * (including their related records data)!\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async import(\r\n        collections: Array<CollectionModel>,\r\n        deleteMissing: boolean = false,\r\n        options?: CommonOptions,\r\n    ): Promise<true> {\r\n        options = Object.assign(\r\n            {\r\n                method: \"PUT\",\r\n                body: {\r\n                    collections: collections,\r\n                    deleteMissing: deleteMissing,\r\n                },\r\n            },\r\n            options,\r\n        );\r\n\r\n        return this.client.send(this.baseCrudPath + \"/import\", options).then(() => true);\r\n    }\r\n}\r\n","import { ClientResponseError } from \"@/ClientResponseError\";\r\nimport { BaseService } from \"@/services/utils/BaseService\";\r\nimport { ListResult, LogModel } from \"@/services/utils/dtos\";\r\nimport { CommonOptions, ListOptions, LogStatsOptions } from \"@/services/utils/options\";\r\n\r\nexport interface HourlyStats {\r\n    total: number;\r\n    date: string;\r\n}\r\n\r\nexport class LogService extends BaseService {\r\n    /**\r\n     * Returns paginated logs list.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async getList(\r\n        page = 1,\r\n        perPage = 30,\r\n        options?: ListOptions,\r\n    ): Promise<ListResult<LogModel>> {\r\n        options = Object.assign({ method: \"GET\" }, options);\r\n\r\n        options.query = Object.assign(\r\n            {\r\n                page: page,\r\n                perPage: perPage,\r\n            },\r\n            options.query,\r\n        );\r\n\r\n        return this.client.send(\"/api/logs\", options);\r\n    }\r\n\r\n    /**\r\n     * Returns a single log by its id.\r\n     *\r\n     * If `id` is empty it will throw a 404 error.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async getOne(id: string, options?: CommonOptions): Promise<LogModel> {\r\n        if (!id) {\r\n            throw new ClientResponseError({\r\n                url: this.client.buildUrl(\"/api/logs/\"),\r\n                status: 404,\r\n                response: {\r\n                    code: 404,\r\n                    message: \"Missing required log id.\",\r\n                    data: {},\r\n                },\r\n            });\r\n        }\r\n\r\n        options = Object.assign(\r\n            {\r\n                method: \"GET\",\r\n            },\r\n            options,\r\n        );\r\n\r\n        return this.client.send(\"/api/logs/\" + encodeURIComponent(id), options);\r\n    }\r\n\r\n    /**\r\n     * Returns logs statistics.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async getStats(options?: LogStatsOptions): Promise<Array<HourlyStats>> {\r\n        options = Object.assign(\r\n            {\r\n                method: \"GET\",\r\n            },\r\n            options,\r\n        );\r\n\r\n        return this.client.send(\"/api/logs/stats\", options);\r\n    }\r\n}\r\n","import { BaseService } from \"@/services/utils/BaseService\";\r\nimport { CommonOptions } from \"@/services/utils/options\";\r\n\r\nexport interface HealthCheckResponse {\r\n    code: number;\r\n    message: string;\r\n    data: { [key: string]: any };\r\n}\r\n\r\nexport class HealthService extends BaseService {\r\n    /**\r\n     * Checks the health status of the api.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async check(options?: CommonOptions): Promise<HealthCheckResponse> {\r\n        options = Object.assign(\r\n            {\r\n                method: \"GET\",\r\n            },\r\n            options,\r\n        );\r\n\r\n        return this.client.send(\"/api/health\", options);\r\n    }\r\n}\r\n","import { BaseService } from \"@/services/utils/BaseService\";\r\nimport { CommonOptions, FileOptions } from \"@/services/utils/options\";\r\n\r\nexport class FileService extends BaseService {\r\n    /**\r\n     * Builds and returns an absolute record file url for the provided filename.\r\n     */\r\n    getUrl(\r\n        record: { [key: string]: any },\r\n        filename: string,\r\n        queryParams: FileOptions = {},\r\n    ): string {\r\n        if (\r\n            !filename ||\r\n            !record?.id ||\r\n            !(record?.collectionId || record?.collectionName)\r\n        ) {\r\n            return \"\";\r\n        }\r\n\r\n        const parts = [];\r\n        parts.push(\"api\");\r\n        parts.push(\"files\");\r\n        parts.push(encodeURIComponent(record.collectionId || record.collectionName));\r\n        parts.push(encodeURIComponent(record.id));\r\n        parts.push(encodeURIComponent(filename));\r\n\r\n        let result = this.client.buildUrl(parts.join(\"/\"));\r\n\r\n        if (Object.keys(queryParams).length) {\r\n            // normalize the download query param for consistency with the Dart sdk\r\n            if (queryParams.download === false) {\r\n                delete queryParams.download;\r\n            }\r\n\r\n            const params = new URLSearchParams(queryParams);\r\n\r\n            result += (result.includes(\"?\") ? \"&\" : \"?\") + params;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Requests a new private file access token for the current auth model (admin or record).\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async getToken(options?: CommonOptions): Promise<string> {\r\n        options = Object.assign(\r\n            {\r\n                method: \"POST\",\r\n            },\r\n            options,\r\n        );\r\n\r\n        return this.client\r\n            .send(\"/api/files/token\", options)\r\n            .then((data) => data?.token || \"\");\r\n    }\r\n}\r\n","import { BaseService } from \"@/services/utils/BaseService\";\r\nimport { CommonOptions } from \"@/services/utils/options\";\r\n\r\nexport interface BackupFileInfo {\r\n    key: string;\r\n    size: number;\r\n    modified: string;\r\n}\r\n\r\nexport class BackupService extends BaseService {\r\n    /**\r\n     * Returns list with all available backup files.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async getFullList(options?: CommonOptions): Promise<Array<BackupFileInfo>> {\r\n        options = Object.assign(\r\n            {\r\n                method: \"GET\",\r\n            },\r\n            options,\r\n        );\r\n\r\n        return this.client.send(\"/api/backups\", options);\r\n    }\r\n\r\n    /**\r\n     * Initializes a new backup.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async create(basename: string, options?: CommonOptions): Promise<boolean> {\r\n        options = Object.assign(\r\n            {\r\n                method: \"POST\",\r\n                body: {\r\n                    name: basename,\r\n                },\r\n            },\r\n            options,\r\n        );\r\n\r\n        return this.client.send(\"/api/backups\", options).then(() => true);\r\n    }\r\n\r\n    /**\r\n     * Uploads an existing backup file.\r\n     *\r\n     * Example:\r\n     *\r\n     * ```js\r\n     * await pb.backups.upload({\r\n     *     file: new Blob([...]),\r\n     * });\r\n     * ```\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async upload(\r\n        bodyParams: { [key: string]: any } | FormData,\r\n        options?: CommonOptions,\r\n    ): Promise<boolean> {\r\n        options = Object.assign(\r\n            {\r\n                method: \"POST\",\r\n                body: bodyParams,\r\n            },\r\n            options,\r\n        );\r\n\r\n        return this.client.send(\"/api/backups/upload\", options).then(() => true);\r\n    }\r\n\r\n    /**\r\n     * Deletes a single backup file.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async delete(key: string, options?: CommonOptions): Promise<boolean> {\r\n        options = Object.assign(\r\n            {\r\n                method: \"DELETE\",\r\n            },\r\n            options,\r\n        );\r\n\r\n        return this.client\r\n            .send(`/api/backups/${encodeURIComponent(key)}`, options)\r\n            .then(() => true);\r\n    }\r\n\r\n    /**\r\n     * Initializes an app data restore from an existing backup.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async restore(key: string, options?: CommonOptions): Promise<boolean> {\r\n        options = Object.assign(\r\n            {\r\n                method: \"POST\",\r\n            },\r\n            options,\r\n        );\r\n\r\n        return this.client\r\n            .send(`/api/backups/${encodeURIComponent(key)}/restore`, options)\r\n            .then(() => true);\r\n    }\r\n\r\n    /**\r\n     * Builds a download url for a single existing backup using an\r\n     * admin file token and the backup file key.\r\n     *\r\n     * The file token can be generated via `pb.files.getToken()`.\r\n     */\r\n    getDownloadUrl(token: string, key: string): string {\r\n        return this.client.buildUrl(\r\n            `/api/backups/${encodeURIComponent(key)}?token=${encodeURIComponent(token)}`,\r\n        );\r\n    }\r\n}\r\n","import { BaseAuthStore, AuthModel } from \"@/stores/BaseAuthStore\";\r\n\r\nexport type AsyncSaveFunc = (serializedPayload: string) => Promise<void>;\r\n\r\nexport type AsyncClearFunc = () => Promise<void>;\r\n\r\ntype queueFunc = () => Promise<void>;\r\n\r\n/**\r\n * AsyncAuthStore is a helper auth store implementation\r\n * that could be used with any external async persistent layer\r\n * (key-value db, local file, etc.).\r\n *\r\n * Here is an example with the React Native AsyncStorage package:\r\n *\r\n * ```\r\n * import AsyncStorage from \"@react-native-async-storage/async-storage\";\r\n * import PocketBase, { AsyncAuthStore } from \"pocketbase\";\r\n *\r\n * const store = new AsyncAuthStore({\r\n *     save:    async (serialized) => AsyncStorage.setItem(\"pb_auth\", serialized),\r\n *     initial: AsyncStorage.getItem(\"pb_auth\"),\r\n * });\r\n *\r\n * const pb = new PocketBase(\"https://example.com\", store)\r\n * ```\r\n */\r\nexport class AsyncAuthStore extends BaseAuthStore {\r\n    private saveFunc: AsyncSaveFunc;\r\n    private clearFunc?: AsyncClearFunc;\r\n    private queue: Array<queueFunc> = [];\r\n\r\n    constructor(config: {\r\n        // The async function that is called every time\r\n        // when the auth store state needs to be persisted.\r\n        save: AsyncSaveFunc;\r\n\r\n        /// An *optional* async function that is called every time\r\n        /// when the auth store needs to be cleared.\r\n        ///\r\n        /// If not explicitly set, `saveFunc` with empty data will be used.\r\n        clear?: AsyncClearFunc;\r\n\r\n        // An *optional* initial data to load into the store.\r\n        initial?: string | Promise<any>;\r\n    }) {\r\n        super();\r\n\r\n        this.saveFunc = config.save;\r\n        this.clearFunc = config.clear;\r\n\r\n        this._enqueue(() => this._loadInitial(config.initial));\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    save(token: string, model?: AuthModel): void {\r\n        super.save(token, model);\r\n\r\n        let value = \"\";\r\n        try {\r\n            value = JSON.stringify({ token, model });\r\n        } catch (err) {\r\n            console.warn(\"AsyncAuthStore: failed to stringify the new state\");\r\n        }\r\n\r\n        this._enqueue(() => this.saveFunc(value));\r\n    }\r\n\r\n    /**\r\n     * @inheritdoc\r\n     */\r\n    clear(): void {\r\n        super.clear();\r\n\r\n        if (this.clearFunc) {\r\n            this._enqueue(() => this.clearFunc!());\r\n        } else {\r\n            this._enqueue(() => this.saveFunc(\"\"));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes the auth store state.\r\n     */\r\n    private async _loadInitial(payload?: string | Promise<any>) {\r\n        try {\r\n            payload = await payload;\r\n\r\n            if (payload) {\r\n                let parsed;\r\n                if (typeof payload === \"string\") {\r\n                    parsed = JSON.parse(payload) || {};\r\n                } else if (typeof payload === \"object\") {\r\n                    parsed = payload;\r\n                }\r\n\r\n                this.save(parsed.token || \"\", parsed.model || null);\r\n            }\r\n        } catch (_) {}\r\n    }\r\n\r\n    /**\r\n     * Appends an async function to the queue.\r\n     */\r\n    private _enqueue(asyncCallback: () => Promise<void>) {\r\n        this.queue.push(asyncCallback);\r\n\r\n        if (this.queue.length == 1) {\r\n            this._dequeue();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts the queue processing.\r\n     */\r\n    private _dequeue() {\r\n        if (!this.queue.length) {\r\n            return;\r\n        }\r\n\r\n        this.queue[0]().finally(() => {\r\n            this.queue.shift();\r\n\r\n            if (!this.queue.length) {\r\n                return;\r\n            }\r\n\r\n            this._dequeue();\r\n        });\r\n    }\r\n}\r\n","import { ClientResponseError } from \"@/ClientResponseError\";\r\nimport { BaseAuthStore } from \"@/stores/BaseAuthStore\";\r\nimport { LocalAuthStore } from \"@/stores/LocalAuthStore\";\r\nimport { SettingsService } from \"@/services/SettingsService\";\r\nimport { AdminService } from \"@/services/AdminService\";\r\nimport { RecordService } from \"@/services/RecordService\";\r\nimport { CollectionService } from \"@/services/CollectionService\";\r\nimport { LogService } from \"@/services/LogService\";\r\nimport { RealtimeService } from \"@/services/RealtimeService\";\r\nimport { HealthService } from \"@/services/HealthService\";\r\nimport { FileService } from \"@/services/FileService\";\r\nimport { BackupService } from \"@/services/BackupService\";\r\nimport { RecordModel } from \"@/services/utils/dtos\";\r\nimport {\r\n    SendOptions,\r\n    FileOptions,\r\n    normalizeUnknownQueryParams,\r\n} from \"@/services/utils/options\";\r\n\r\nexport interface BeforeSendResult {\r\n    [key: string]: any; // for backward compatibility\r\n    url?: string;\r\n    options?: { [key: string]: any };\r\n}\r\n\r\n/**\r\n * PocketBase JS Client.\r\n */\r\nexport default class Client {\r\n    /**\r\n     * The base PocketBase backend url address (eg. 'http://127.0.0.1.8090').\r\n     */\r\n    baseUrl: string;\r\n\r\n    /**\r\n     * Hook that get triggered right before sending the fetch request,\r\n     * allowing you to inspect and modify the url and request options.\r\n     *\r\n     * For list of the possible options check https://developer.mozilla.org/en-US/docs/Web/API/fetch#options\r\n     *\r\n     * You can return a non-empty result object `{ url, options }` to replace the url and request options entirely.\r\n     *\r\n     * Example:\r\n     * ```js\r\n     * client.beforeSend = function (url, options) {\r\n     *     options.headers = Object.assign({}, options.headers, {\r\n     *         'X-Custom-Header': 'example',\r\n     *     });\r\n     *\r\n     *     return { url, options }\r\n     * };\r\n     * ```\r\n     */\r\n    beforeSend?: (\r\n        url: string,\r\n        options: SendOptions,\r\n    ) => BeforeSendResult | Promise<BeforeSendResult>;\r\n\r\n    /**\r\n     * Hook that get triggered after successfully sending the fetch request,\r\n     * allowing you to inspect/modify the response object and its parsed data.\r\n     *\r\n     * Returns the new Promise resolved `data` that will be returned to the client.\r\n     *\r\n     * Example:\r\n     * ```js\r\n     * client.afterSend = function (response, data) {\r\n     *     if (response.status != 200) {\r\n     *         throw new ClientResponseError({\r\n     *             url:      response.url,\r\n     *             status:   response.status,\r\n     *             response: { ... },\r\n     *         });\r\n     *     }\r\n     *\r\n     *     return data;\r\n     * };\r\n     * ```\r\n     */\r\n    afterSend?: (response: Response, data: any) => any;\r\n\r\n    /**\r\n     * Optional language code (default to `en-US`) that will be sent\r\n     * with the requests to the server as `Accept-Language` header.\r\n     */\r\n    lang: string;\r\n\r\n    /**\r\n     * A replaceable instance of the local auth store service.\r\n     */\r\n    authStore: BaseAuthStore;\r\n\r\n    /**\r\n     * An instance of the service that handles the **Settings APIs**.\r\n     */\r\n    readonly settings: SettingsService;\r\n\r\n    /**\r\n     * An instance of the service that handles the **Admin APIs**.\r\n     */\r\n    readonly admins: AdminService;\r\n\r\n    /**\r\n     * An instance of the service that handles the **Collection APIs**.\r\n     */\r\n    readonly collections: CollectionService;\r\n\r\n    /**\r\n     * An instance of the service that handles the **File APIs**.\r\n     */\r\n    readonly files: FileService;\r\n\r\n    /**\r\n     * An instance of the service that handles the **Log APIs**.\r\n     */\r\n    readonly logs: LogService;\r\n\r\n    /**\r\n     * An instance of the service that handles the **Realtime APIs**.\r\n     */\r\n    readonly realtime: RealtimeService;\r\n\r\n    /**\r\n     * An instance of the service that handles the **Health APIs**.\r\n     */\r\n    readonly health: HealthService;\r\n\r\n    /**\r\n     * An instance of the service that handles the **Backup APIs**.\r\n     */\r\n    readonly backups: BackupService;\r\n\r\n    private cancelControllers: { [key: string]: AbortController } = {};\r\n    private recordServices: { [key: string]: RecordService } = {};\r\n    private enableAutoCancellation: boolean = true;\r\n\r\n    constructor(baseUrl = \"/\", authStore?: BaseAuthStore | null, lang = \"en-US\") {\r\n        this.baseUrl = baseUrl;\r\n        this.lang = lang;\r\n        this.authStore = authStore || new LocalAuthStore();\r\n\r\n        // services\r\n        this.admins = new AdminService(this);\r\n        this.collections = new CollectionService(this);\r\n        this.files = new FileService(this);\r\n        this.logs = new LogService(this);\r\n        this.settings = new SettingsService(this);\r\n        this.realtime = new RealtimeService(this);\r\n        this.health = new HealthService(this);\r\n        this.backups = new BackupService(this);\r\n    }\r\n\r\n    /**\r\n     * Returns the RecordService associated to the specified collection.\r\n     *\r\n     * @param  {string} idOrName\r\n     * @return {RecordService}\r\n     */\r\n    collection<M = RecordModel>(idOrName: string): RecordService<M> {\r\n        if (!this.recordServices[idOrName]) {\r\n            this.recordServices[idOrName] = new RecordService(this, idOrName);\r\n        }\r\n\r\n        return this.recordServices[idOrName];\r\n    }\r\n\r\n    /**\r\n     * Globally enable or disable auto cancellation for pending duplicated requests.\r\n     */\r\n    autoCancellation(enable: boolean): Client {\r\n        this.enableAutoCancellation = !!enable;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Cancels single request by its cancellation key.\r\n     */\r\n    cancelRequest(requestKey: string): Client {\r\n        if (this.cancelControllers[requestKey]) {\r\n            this.cancelControllers[requestKey].abort();\r\n            delete this.cancelControllers[requestKey];\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Cancels all pending requests.\r\n     */\r\n    cancelAllRequests(): Client {\r\n        for (let k in this.cancelControllers) {\r\n            this.cancelControllers[k].abort();\r\n        }\r\n\r\n        this.cancelControllers = {};\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Constructs a filter expression with placeholders populated from a parameters object.\r\n     *\r\n     * Placeholder parameters are defined with the `{:paramName}` notation.\r\n     *\r\n     * The following parameter values are supported:\r\n     *\r\n     * - `string` (_single quotes are autoescaped_)\r\n     * - `number`\r\n     * - `boolean`\r\n     * - `Date` object (_stringified into the PocketBase datetime format_)\r\n     * - `null`\r\n     * - everything else is converted to a string using `JSON.stringify()`\r\n     *\r\n     * Example:\r\n     *\r\n     * ```js\r\n     * pb.collection(\"example\").getFirstListItem(pb.filter(\r\n     *    'title ~ {:title} && created >= {:created}',\r\n     *    { title: \"example\", created: new Date()}\r\n     * ))\r\n     * ```\r\n     */\r\n    filter(raw: string, params?: { [key: string]: any }): string {\r\n        if (!params) {\r\n            return raw;\r\n        }\r\n\r\n        for (let key in params) {\r\n            let val = params[key];\r\n            switch (typeof val) {\r\n                case \"boolean\":\r\n                case \"number\":\r\n                    val = \"\" + val;\r\n                    break;\r\n                case \"string\":\r\n                    val = \"'\" + val.replace(/'/g, \"\\\\'\") + \"'\";\r\n                    break;\r\n                default:\r\n                    if (val === null) {\r\n                        val = \"null\";\r\n                    } else if (val instanceof Date) {\r\n                        val = \"'\" + val.toISOString().replace(\"T\", \" \") + \"'\";\r\n                    } else {\r\n                        val = \"'\" + JSON.stringify(val).replace(/'/g, \"\\\\'\") + \"'\";\r\n                    }\r\n            }\r\n            raw = raw.replaceAll(\"{:\" + key + \"}\", val);\r\n        }\r\n\r\n        return raw;\r\n    }\r\n\r\n    /**\r\n     * Legacy alias of `pb.files.getUrl()`.\r\n     */\r\n    getFileUrl(\r\n        record: { [key: string]: any },\r\n        filename: string,\r\n        queryParams: FileOptions = {},\r\n    ): string {\r\n        return this.files.getUrl(record, filename, queryParams);\r\n    }\r\n\r\n    /**\r\n     * Builds a full client url by safely concatenating the provided path.\r\n     */\r\n    buildUrl(path: string): string {\r\n        let url = this.baseUrl;\r\n\r\n        // construct an absolute base url if in a browser environment\r\n        if (\r\n            typeof window !== \"undefined\" &&\r\n            !!window.location &&\r\n            !url.startsWith(\"https://\") &&\r\n            !url.startsWith(\"http://\")\r\n        ) {\r\n            url = window.location.origin?.endsWith(\"/\")\r\n                ? window.location.origin.substring(0, window.location.origin.length - 1)\r\n                : window.location.origin || \"\";\r\n\r\n            if (!this.baseUrl.startsWith(\"/\")) {\r\n                url += window.location.pathname || \"/\";\r\n                url += url.endsWith(\"/\") ? \"\" : \"/\";\r\n            }\r\n\r\n            url += this.baseUrl;\r\n        }\r\n\r\n        // concatenate the path\r\n        if (path) {\r\n            url += url.endsWith(\"/\") ? \"\" : \"/\"; // append trailing slash if missing\r\n            url += path.startsWith(\"/\") ? path.substring(1) : path;\r\n        }\r\n\r\n        return url;\r\n    }\r\n\r\n    /**\r\n     * Sends an api http request.\r\n     *\r\n     * @throws {ClientResponseError}\r\n     */\r\n    async send<T = any>(path: string, options: SendOptions): Promise<T> {\r\n        options = this.initSendOptions(path, options);\r\n\r\n        // build url + path\r\n        let url = this.buildUrl(path);\r\n\r\n        if (this.beforeSend) {\r\n            const result = Object.assign({}, await this.beforeSend(url, options));\r\n            if (\r\n                typeof result.url !== \"undefined\" ||\r\n                typeof result.options !== \"undefined\"\r\n            ) {\r\n                url = result.url || url;\r\n                options = result.options || options;\r\n            } else if (Object.keys(result).length) {\r\n                // legacy behavior\r\n                options = result as SendOptions;\r\n                console?.warn &&\r\n                    console.warn(\r\n                        \"Deprecated format of beforeSend return: please use `return { url, options }`, instead of `return options`.\",\r\n                    );\r\n            }\r\n        }\r\n\r\n        // serialize the query parameters\r\n        if (typeof options.query !== \"undefined\") {\r\n            const query = this.serializeQueryParams(options.query);\r\n            if (query) {\r\n                url += (url.includes(\"?\") ? \"&\" : \"?\") + query;\r\n            }\r\n            delete options.query;\r\n        }\r\n\r\n        // ensures that the json body is serialized\r\n        if (\r\n            this.getHeader(options.headers, \"Content-Type\") == \"application/json\" &&\r\n            options.body &&\r\n            typeof options.body !== \"string\"\r\n        ) {\r\n            options.body = JSON.stringify(options.body);\r\n        }\r\n\r\n        const fetchFunc = options.fetch || fetch;\r\n\r\n        // send the request\r\n        return fetchFunc(url, options)\r\n            .then(async (response) => {\r\n                let data: any = {};\r\n\r\n                try {\r\n                    data = await response.json();\r\n                } catch (_) {\r\n                    // all api responses are expected to return json\r\n                    // with the exception of the realtime event and 204\r\n                }\r\n\r\n                if (this.afterSend) {\r\n                    data = await this.afterSend(response, data);\r\n                }\r\n\r\n                if (response.status >= 400) {\r\n                    throw new ClientResponseError({\r\n                        url: response.url,\r\n                        status: response.status,\r\n                        data: data,\r\n                    });\r\n                }\r\n\r\n                return data as T;\r\n            })\r\n            .catch((err) => {\r\n                // wrap to normalize all errors\r\n                throw new ClientResponseError(err);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Shallow copy the provided object and takes care to initialize\r\n     * any options required to preserve the backward compatability.\r\n     *\r\n     * @param  {SendOptions} options\r\n     * @return {SendOptions}\r\n     */\r\n    private initSendOptions(path: string, options: SendOptions): SendOptions {\r\n        options = Object.assign({ method: \"GET\" } as SendOptions, options);\r\n\r\n        // auto convert the body to FormData, if needed\r\n        options.body = this.convertToFormDataIfNeeded(options.body);\r\n\r\n        // move unknown send options as query parameters\r\n        normalizeUnknownQueryParams(options);\r\n\r\n        // requestKey normalizations for backward-compatibility\r\n        // ---\r\n        options.query = Object.assign({}, options.params, options.query);\r\n        if (typeof options.requestKey === \"undefined\") {\r\n            if (options.$autoCancel === false || options.query.$autoCancel === false) {\r\n                options.requestKey = null;\r\n            } else if (options.$cancelKey || options.query.$cancelKey) {\r\n                options.requestKey = options.$cancelKey || options.query.$cancelKey;\r\n            }\r\n        }\r\n        // remove the deprecated special cancellation params from the other query params\r\n        delete options.$autoCancel;\r\n        delete options.query.$autoCancel;\r\n        delete options.$cancelKey;\r\n        delete options.query.$cancelKey;\r\n        // ---\r\n\r\n        // add the json header, if not explicitly set\r\n        // (for FormData body the Content-Type header should be skipped since the boundary is autogenerated)\r\n        if (\r\n            this.getHeader(options.headers, \"Content-Type\") === null &&\r\n            !this.isFormData(options.body)\r\n        ) {\r\n            options.headers = Object.assign({}, options.headers, {\r\n                \"Content-Type\": \"application/json\",\r\n            });\r\n        }\r\n\r\n        // add Accept-Language header, if not explicitly set\r\n        if (this.getHeader(options.headers, \"Accept-Language\") === null) {\r\n            options.headers = Object.assign({}, options.headers, {\r\n                \"Accept-Language\": this.lang,\r\n            });\r\n        }\r\n\r\n        // check if Authorization header can be added\r\n        if (\r\n            // has valid token\r\n            this.authStore.token &&\r\n            // auth header is not explicitly set\r\n            this.getHeader(options.headers, \"Authorization\") === null\r\n        ) {\r\n            options.headers = Object.assign({}, options.headers, {\r\n                Authorization: this.authStore.token,\r\n            });\r\n        }\r\n\r\n        // handle auto cancelation for duplicated pending request\r\n        if (this.enableAutoCancellation && options.requestKey !== null) {\r\n            const requestKey = options.requestKey || (options.method || \"GET\") + path;\r\n\r\n            delete options.requestKey;\r\n\r\n            // cancel previous pending requests\r\n            this.cancelRequest(requestKey);\r\n\r\n            const controller = new AbortController();\r\n            this.cancelControllers[requestKey] = controller;\r\n            options.signal = controller.signal;\r\n        }\r\n\r\n        return options;\r\n    }\r\n\r\n    /**\r\n     * Converts analyzes the provided body and converts it to FormData\r\n     * in case a plain object with File/Blob values is used.\r\n     */\r\n    private convertToFormDataIfNeeded(body: any): any {\r\n        if (\r\n            typeof FormData === \"undefined\" ||\r\n            typeof body === \"undefined\" ||\r\n            typeof body !== \"object\" ||\r\n            body === null ||\r\n            this.isFormData(body) ||\r\n            !this.hasBlobField(body)\r\n        ) {\r\n            return body;\r\n        }\r\n\r\n        const form = new FormData();\r\n\r\n        for (const key in body) {\r\n            const val = body[key];\r\n\r\n            if (typeof val === \"object\" && !this.hasBlobField({ data: val })) {\r\n                // send json-like values as jsonPayload to avoid the implicit string value normalization\r\n                let payload: { [key: string]: any } = {};\r\n                payload[key] = val;\r\n                form.append(\"@jsonPayload\", JSON.stringify(payload));\r\n            } else {\r\n                // in case of mixed string and file/blob\r\n                const normalizedVal = Array.isArray(val) ? val : [val];\r\n                for (let v of normalizedVal) {\r\n                    form.append(key, v);\r\n                }\r\n            }\r\n        }\r\n\r\n        return form;\r\n    }\r\n\r\n    /**\r\n     * Checks if the submitted body object has at least one Blob/File field.\r\n     */\r\n    private hasBlobField(body: { [key: string]: any }): boolean {\r\n        for (const key in body) {\r\n            const values = Array.isArray(body[key]) ? body[key] : [body[key]];\r\n            for (const v of values) {\r\n                if (\r\n                    (typeof Blob !== \"undefined\" && v instanceof Blob) ||\r\n                    (typeof File !== \"undefined\" && v instanceof File)\r\n                ) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Extracts the header with the provided name in case-insensitive manner.\r\n     * Returns `null` if no header matching the name is found.\r\n     */\r\n    private getHeader(\r\n        headers: { [key: string]: string } | undefined,\r\n        name: string,\r\n    ): string | null {\r\n        headers = headers || {};\r\n        name = name.toLowerCase();\r\n\r\n        for (let key in headers) {\r\n            if (key.toLowerCase() == name) {\r\n                return headers[key];\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Loosely checks if the specified body is a FormData instance.\r\n     */\r\n    private isFormData(body: any): boolean {\r\n        return (\r\n            body &&\r\n            // we are checking the constructor name because FormData\r\n            // is not available natively in some environments and the\r\n            // polyfill(s) may not be globally accessible\r\n            (body.constructor.name === \"FormData\" ||\r\n                // fallback to global FormData instance check\r\n                // note: this is needed because the constructor.name could be different in case of\r\n                //       custom global FormData implementation, eg. React Native on Android/iOS\r\n                (typeof FormData !== \"undefined\" && body instanceof FormData))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Serializes the provided query parameters into a query string.\r\n     */\r\n    private serializeQueryParams(params: { [key: string]: any }): string {\r\n        const result: Array<string> = [];\r\n        for (const key in params) {\r\n            if (params[key] === null) {\r\n                // skip null query params\r\n                continue;\r\n            }\r\n\r\n            const value = params[key];\r\n            const encodedKey = encodeURIComponent(key);\r\n\r\n            if (Array.isArray(value)) {\r\n                // repeat array params\r\n                for (const v of value) {\r\n                    result.push(encodedKey + \"=\" + encodeURIComponent(v));\r\n                }\r\n            } else if (value instanceof Date) {\r\n                result.push(encodedKey + \"=\" + encodeURIComponent(value.toISOString()));\r\n            } else if (typeof value !== null && typeof value === \"object\") {\r\n                result.push(encodedKey + \"=\" + encodeURIComponent(JSON.stringify(value)));\r\n            } else {\r\n                result.push(encodedKey + \"=\" + encodeURIComponent(value));\r\n            }\r\n        }\r\n\r\n        return result.join(\"&\");\r\n    }\r\n}\r\n"],"names":["ClientResponseError","Error","constructor","errData","super","this","url","status","response","isAbort","originalError","Object","setPrototypeOf","prototype","data","DOMException","name","message","cause","includes","toJSON","fieldContentRegExp","cookieParse","str","options","result","decode","assign","defaultDecode","index","length","eqIdx","indexOf","endIdx","lastIndexOf","key","slice","trim","undefined","val","charCodeAt","_","cookieSerialize","opt","encode","defaultEncode","test","TypeError","value","maxAge","isNaN","isFinite","Math","floor","domain","path","expires","isDate","toString","call","Date","valueOf","toUTCString","httpOnly","secure","priority","toLowerCase","sameSite","decodeURIComponent","encodeURIComponent","isReactNative","navigator","product","global","HermesInternal","atobPolyfill","getTokenPayload","token","encodedPayload","split","map","c","join","JSON","parse","e","isTokenExpired","expirationThreshold","payload","keys","exp","now","atob","input","String","replace","bs","buffer","bc","idx","output","charAt","fromCharCode","defaultCookieKey","BaseAuthStore","baseToken","baseModel","_onChangeCallbacks","model","isValid","isAdmin","type","isAuthRecord","save","triggerChange","clear","loadFromCookie","cookie","rawData","Array","isArray","exportToCookie","defaultOptions","stringify","resultLength","Blob","size","id","email","extraProps","prop","onChange","callback","fireImmediately","push","i","splice","LocalAuthStore","storageKey","storageFallback","_bindStorageEvent","_storageGet","_storageSet","_storageRemove","window","localStorage","rawValue","getItem","normalizedVal","setItem","removeItem","addEventListener","BaseService","client","SettingsService","getAll","method","send","update","bodyParams","body","testS3","filesystem","then","testEmail","toEmail","emailTemplate","template","generateAppleClientSecret","clientId","teamId","keyId","privateKey","duration","CrudService","getFullList","batchOrqueryParams","_getFullList","batch","getList","page","perPage","query","baseCrudPath","responseData","items","item","getFirstListItem","filter","requestKey","skipTotal","code","getOne","buildUrl","create","batchSize","request","async","list","concat","normalizeLegacyOptionsArgs","legacyWarn","baseOptions","bodyOrOptions","hasQuery","console","warn","resetAutoRefresh","_resetAutoRefresh","AdminService","authStore","collectionId","delete","success","authResponse","admin","authWithPassword","password","identity","autoRefreshThreshold","autoRefresh","authData","registerAutoRefresh","threshold","refreshFunc","reauthenticateFunc","oldBeforeSend","beforeSend","oldModel","unsubStoreChange","newToken","sendOptions","oldToken","headers","authRefresh","bind","requestPasswordReset","confirmPasswordReset","resetToken","passwordConfirm","knownSendOptionsKeys","normalizeUnknownQueryParams","RealtimeService","eventSource","subscriptions","lastSentSubscriptions","maxConnectTimeout","reconnectAttempts","maxReconnectAttempts","Infinity","predefinedReconnectIntervals","pendingConnects","isConnected","subscribe","topic","serialized","listener","msgEvent","submitSubscriptions","connect","unsubscribeByTopicAndListener","unsubscribe","needToSubmit","subs","getSubscriptionsByTopic","hasSubscriptionListeners","removeEventListener","disconnect","unsubscribeByPrefix","keyPrefix","hasAtleastOneTopic","startsWith","exist","keyToCheck","addAllSubscriptionListeners","getNonEmptySubscriptionKeys","getSubscriptionsCancelKey","catch","err","removeAllSubscriptionListeners","Promise","resolve","reject","initConnect","clearTimeout","connectTimeoutId","setTimeout","connectErrorHandler","EventSource","onerror","lastEventId","retries","hasUnsentSubscriptions","p","reconnectTimeoutId","connectSubs","latestTopics","t","timeout","fromReconnect","cancelRequest","close","RecordService","collectionIdOrName","baseCollectionPath","realtime","batchOrOptions","params","collectionName","record","listAuthMethods","usernamePassword","emailPassword","authProviders","usernameOrEmail","authWithOAuth2Code","provider","codeVerifier","redirectUrl","createData","authWithOAuth2","args","config","find","eagerDefaultPopup","cleanup","urlCallback","openBrowserPopup","oldState","state","error","scopes","replacements","_replaceQueryParams","authUrl","location","href","passwordResetToken","requestVerification","confirmVerification","verificationToken","verified","requestEmailChange","newEmail","confirmEmailChange","emailChangeToken","listExternalAuths","recordId","unlinkExternalAuth","urlPath","substring","parsedParams","rawParams","param","pair","hasOwnProperty","open","width","height","windowWidth","innerWidth","windowHeight","innerHeight","left","top","CollectionService","import","collections","deleteMissing","LogService","getStats","HealthService","check","FileService","getUrl","filename","queryParams","parts","download","URLSearchParams","getToken","BackupService","basename","upload","restore","getDownloadUrl","AsyncAuthStore","queue","saveFunc","clearFunc","_enqueue","_loadInitial","initial","parsed","asyncCallback","_dequeue","finally","shift","Client","baseUrl","lang","cancelControllers","recordServices","enableAutoCancellation","admins","files","logs","settings","health","backups","collection","idOrName","autoCancellation","enable","abort","cancelAllRequests","k","raw","toISOString","replaceAll","getFileUrl","origin","endsWith","pathname","initSendOptions","serializeQueryParams","getHeader","fetch","json","afterSend","convertToFormDataIfNeeded","$autoCancel","$cancelKey","isFormData","Authorization","controller","AbortController","signal","FormData","hasBlobField","form","v","append","values","File","encodedKey"],"mappings":"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"}